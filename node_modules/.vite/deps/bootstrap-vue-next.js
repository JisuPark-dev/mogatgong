import "./chunk-ZHVR2J3H.js";
import {
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  isReactive,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toHandlers,
  toRef,
  toValue,
  unref,
  useAttrs,
  useSlots,
  vModelCheckbox,
  vModelRadio,
  vModelSelect,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-6PKISRC3.js";
import "./chunk-WJNEFWWE.js";

// node_modules/bootstrap-vue-next/dist/bootstrap-vue-next.mjs
var Mn = Object.defineProperty;
var Dn = (e, t, l) => t in e ? Mn(e, t, { enumerable: true, configurable: true, writable: true, value: l }) : e[t] = l;
var Pe = (e, t, l) => (Dn(e, typeof t != "symbol" ? t + "" : t, l), l);
var es = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false";
var Ma = (e) => typeof e == "boolean" ? e : e === "" || e === "true";
var Je = class _Je {
  constructor(t, l = {}) {
    Pe(this, "cancelable", true);
    Pe(this, "componentId", null);
    Pe(this, "_defaultPrevented", false);
    Pe(this, "eventType", "");
    Pe(this, "nativeEvent", null);
    Pe(this, "_preventDefault");
    Pe(this, "relatedTarget", null);
    Pe(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, _Je.Defaults, l, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = true);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: true,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
};
var Mt = class extends Je {
  constructor(l, a = {}) {
    super(l, a);
    Pe(this, "trigger", null);
    Object.assign(this, Je.Defaults, a, { eventType: l });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
};
var vo = class extends Je {
  constructor(l, a) {
    super(l, a);
    Pe(this, "from");
    Pe(this, "to");
    Pe(this, "direction");
    Object.assign(this, Je.Defaults, a, { eventType: l });
    const { from: o, direction: n, to: s } = a;
    this.from = o, this.to = s, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
};
var Sa = (e) => e !== null && typeof e == "object";
var po = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e));
var ts = (e) => Object.prototype.toString.call(e) === "[object Object]";
var mo = /_/g;
var go = /([a-z])([A-Z])/g;
var as = /(\s|^)(\w)/g;
var ls = /(\s|^)(\w)/;
var Yt = /\s+/;
var os = /^#/;
var ns = /^#[A-Za-z]+[\w\-:.]*$/;
var ss = /-u-.+/;
var rs = /[-/\\^$*+?.()|[\]{}]/g;
var is = /[\s\uFEFF\xA0]+/g;
var Qt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || ts(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e);
var il = (e) => e.replace(mo, " ").replace(go, (t, l, a) => `${l} ${a}`).replace(ls, (t, l, a) => l + a.toUpperCase());
var ul = (e) => e.replace(mo, " ").replace(go, (t, l, a) => `${l} ${a}`).replace(as, (t, l, a) => l + a.toUpperCase());
var us = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
};
var ds = (e) => e.replace(rs, "\\$&");
var cs = (e) => ds(e).replace(is, "\\s");
var ba = (e) => `\\${e}`;
var fs = (e) => {
  const t = Qt(e), { length: l } = t, a = t.charCodeAt(0);
  return t.split("").reduce((o, n, s) => {
    const r = t.charCodeAt(s);
    return r === 0 ? `${o}ï¿½` : (
      // ... is U+007F OR
      r === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
      r >= 1 && r <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
      s === 0 && r >= 48 && r <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D) ...
      s === 1 && r >= 48 && r <= 57 && a === 45 ? o + ba(`${r.toString(16)} `) : (
        // ... is the first character AND ...
        s === 0 && // ... is a `-` (U+002D) AND ...
        r === 45 && // ... there is no second character ...
        l === 1 ? o + ba(n) : (
          // ... is greater than or equal to U+0080 OR ...
          r >= 128 || // ... is `-` (U+002D) OR ...
          r === 45 || // ... is `_` (U+005F) OR ...
          r === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
          r >= 48 && r <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
          r >= 65 && r <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
          r >= 97 && r <= 122 ? o + n : o + ba(n)
        )
      )
    );
  }, "");
};
var yo = typeof window < "u";
var bo = typeof document < "u";
var vs = typeof Element < "u";
var ps = typeof navigator < "u";
var ms = yo && bo && ps;
var dl = yo ? window : {};
var Da = bo ? document : {};
(() => {
  let e = false;
  if (ms)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          return e = true, e;
        }
      };
      dl.addEventListener("test", t, t), dl.removeEventListener("test", t, t);
    } catch {
      e = false;
    }
  return e;
})();
var ja = typeof window < "u";
var gs = typeof document < "u";
var ys = typeof navigator < "u";
var qa = ja && gs && ys;
var cl = ja ? window : {};
var bs = (() => {
  let e = false;
  if (qa)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = true;
        }
      };
      cl.addEventListener("test", t, t), cl.removeEventListener("test", t, t);
    } catch {
      e = false;
    }
  return e;
})();
var He = vs ? Element.prototype : void 0;
var hs = (He == null ? void 0 : He.matches) || (He == null ? void 0 : He.msMatchesSelector) || (He == null ? void 0 : He.webkitMatchesSelector);
var Ze = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE);
var Bs = (e) => Ze(e) ? e.getBoundingClientRect() : null;
var Ss = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((l) => l === t) ? t : null;
};
var _s = (e) => Ze(e) && e === Ss();
var ws = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (l) {
    console.error(l);
  }
  return _s(e);
};
var $s = (e, t) => t && Ze(e) && e.getAttribute(t) || null;
var ks = (e) => {
  if ($s(e, "display") === "none")
    return false;
  const t = Bs(e);
  return !!(t && t.height > 0 && t.width > 0);
};
var Fe = (e) => ((e == null ? void 0 : e()) ?? []).length === 0;
var ho = (e, t) => (Ze(t) ? t : Da).querySelector(e) || null;
var Cs = (e, t) => Array.from([(Ze(t) ? t : Da).querySelectorAll(e)]);
var Ga = (e, t) => t && Ze(e) ? e.getAttribute(t) : null;
var Ts = (e) => Da.getElementById(/^#/.test(e) ? e.slice(1) : e) || null;
var Vs = (e, t, l) => {
  t && Ze(e) && e.setAttribute(t, l);
};
var Os = (e, t) => {
  t && Ze(e) && e.removeAttribute(t);
};
var As = (e, t) => Qt(e).toLowerCase() === Qt(t).toLowerCase();
var Gt = ja ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || // Fallback, but not a true polyfill
// Only needed for Opera Mini
((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0);
var Bo = (e, t) => Ze(e) ? hs.call(e, t) : false;
var Ps = (He == null ? void 0 : He.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if (Bo(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
};
var fl = (e, t, l = false) => {
  if (!Ze(t))
    return null;
  const a = Ps.call(t, e);
  return l ? a : a === t ? null : a;
};
var _a = (e) => {
  const t = window.getComputedStyle(e), l = t.transitionDelay.split(",")[0] || "", a = t.transitionDuration.split(",")[0] || "", o = Number(l.slice(0, -1)) * 1e3, n = Number(a.slice(0, -1)) * 1e3;
  return o + n;
};
var ca = (e, t, l) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((a, o) => (a[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), /* @__PURE__ */ Object.create(null));
var So = (e, t, l, a = l) => Object.keys(t).reduce((o, n) => (e[n] && o.push(
  [a, n.replace(l, ""), e[n]].filter((s) => s && typeof s != "boolean").join("-").toLowerCase()
), o), []);
var lt = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`;
var St = (e) => !!(e.href || e.to);
var Me = (e, t = {}, l = {}) => {
  const a = [e];
  let o;
  for (let n = 0; n < a.length && !o; n++) {
    const s = a[n];
    o = l[s];
  }
  return o && typeof o == "function" ? o(t) : o;
};
var ot = (e, t = NaN) => Number.isInteger(e) ? e : t;
var Es = (e, t = NaN) => {
  const l = Number.parseInt(e, 10);
  return Number.isNaN(l) ? t : l;
};
var Et = (e, t = NaN) => {
  const l = Number.parseFloat(e.toString());
  return Number.isNaN(l) ? t : l;
};
var Fs = (e, t) => Object.keys(e).filter((l) => !t.includes(l)).reduce((l, a) => ({ ...l, [a]: e[a] }), {});
var ea = (e) => Array.isArray(e) ? e.map((t) => ea(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((t, l) => (Object.defineProperty(t, l, Object.getOwnPropertyDescriptor(e, l) ?? {}), t[l] = ea(e[l]), t), Object.create(Object.getPrototypeOf(e))) : e;
var wa = (e) => new Promise((t) => t(ea(e)));
var vl = (e, t) => t + (e ? us(e) : "");
var Dt = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce(
  (l, a) => (l[a] = e[a], l),
  {}
);
var fa = (e, t) => e === true || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === false ? "true" : e === false || e === "false" ? "false" : void 0;
var _o = Symbol("carousel");
var wo = Symbol("tabs");
var $o = Symbol("progress");
var ko = Symbol("listGroup");
var Co = Symbol("avatarGroup");
var To = Symbol("accordion");
var Vo = Symbol("checkboxGroup");
var Oo = Symbol("radioGroup");
var Wa = Symbol("collapse");
var Ao = Symbol("collapse");
var Ua = Symbol("navbar");
var $a = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((l, a) => (typeof a.type == "symbol" ? l = l.concat(a.children) : l.push(a), l), []).filter((l) => {
  var a;
  return ((a = l.type) == null ? void 0 : a.__name) === t;
});
function Ye(e) {
  return e.split("-")[1];
}
function Ka(e) {
  return e === "y" ? "height" : "width";
}
function Ge(e) {
  return e.split("-")[0];
}
function Ct(e) {
  return ["top", "bottom"].includes(Ge(e)) ? "x" : "y";
}
function pl(e, t, l) {
  let { reference: a, floating: o } = e;
  const n = a.x + a.width / 2 - o.width / 2, s = a.y + a.height / 2 - o.height / 2, r = Ct(t), u = Ka(r), f = a[u] / 2 - o[u] / 2, v = r === "x";
  let p;
  switch (Ge(t)) {
    case "top":
      p = { x: n, y: a.y - o.height };
      break;
    case "bottom":
      p = { x: n, y: a.y + a.height };
      break;
    case "right":
      p = { x: a.x + a.width, y: s };
      break;
    case "left":
      p = { x: a.x - o.width, y: s };
      break;
    default:
      p = { x: a.x, y: a.y };
  }
  switch (Ye(t)) {
    case "start":
      p[r] -= f * (l && v ? -1 : 1);
      break;
    case "end":
      p[r] += f * (l && v ? -1 : 1);
  }
  return p;
}
var Is = async (e, t, l) => {
  const { placement: a = "bottom", strategy: o = "absolute", middleware: n = [], platform: s } = l, r = n.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let f = await s.getElementRects({ reference: e, floating: t, strategy: o }), { x: v, y: p } = pl(f, a, u), c = a, g = {}, B = 0;
  for (let m = 0; m < r.length; m++) {
    const { name: V, fn: b } = r[m], { x: T, y: _, data: h2, reset: k } = await b({ x: v, y: p, initialPlacement: a, placement: c, strategy: o, middlewareData: g, rects: f, platform: s, elements: { reference: e, floating: t } });
    v = T ?? v, p = _ ?? p, g = { ...g, [V]: { ...g[V], ...h2 } }, k && B <= 50 && (B++, typeof k == "object" && (k.placement && (c = k.placement), k.rects && (f = k.rects === true ? await s.getElementRects({ reference: e, floating: t, strategy: o }) : k.rects), { x: v, y: p } = pl(f, c, u)), m = -1);
  }
  return { x: v, y: p, placement: c, strategy: o, middlewareData: g };
};
function it(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Xa(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function _t(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Lt(e, t) {
  var l;
  t === void 0 && (t = {});
  const { x: a, y: o, platform: n, rects: s, elements: r, strategy: u } = e, { boundary: f = "clippingAncestors", rootBoundary: v = "viewport", elementContext: p = "floating", altBoundary: c = false, padding: g = 0 } = it(t, e), B = Xa(g), m = r[c ? p === "floating" ? "reference" : "floating" : p], V = _t(await n.getClippingRect({ element: (l = await (n.isElement == null ? void 0 : n.isElement(m))) == null || l ? m : m.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(r.floating)), boundary: f, rootBoundary: v, strategy: u })), b = p === "floating" ? { ...s.floating, x: a, y: o } : s.reference, T = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(r.floating)), _ = await (n.isElement == null ? void 0 : n.isElement(T)) && await (n.getScale == null ? void 0 : n.getScale(T)) || { x: 1, y: 1 }, h2 = _t(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: b, offsetParent: T, strategy: u }) : b);
  return { top: (V.top - h2.top + B.top) / _.y, bottom: (h2.bottom - V.bottom + B.bottom) / _.y, left: (V.left - h2.left + B.left) / _.x, right: (h2.right - V.right + B.right) / _.x };
}
var wt = Math.min;
var ta = Math.max;
function ka(e, t, l) {
  return ta(e, wt(t, l));
}
var xs = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { x: l, y: a, placement: o, rects: n, platform: s, elements: r } = t, { element: u, padding: f = 0 } = it(e, t) || {};
  if (u == null)
    return {};
  const v = Xa(f), p = { x: l, y: a }, c = Ct(o), g = Ka(c), B = await s.getDimensions(u), m = c === "y", V = m ? "top" : "left", b = m ? "bottom" : "right", T = m ? "clientHeight" : "clientWidth", _ = n.reference[g] + n.reference[c] - p[c] - n.floating[g], h2 = p[c] - n.reference[c], k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
  let C = k ? k[T] : 0;
  C && await (s.isElement == null ? void 0 : s.isElement(k)) || (C = r.floating[T] || n.floating[g]);
  const w = _ / 2 - h2 / 2, P = C / 2 - B[g] / 2 - 1, F = wt(v[V], P), S = wt(v[b], P), I = F, x = C - B[g] - S, z = C / 2 - B[g] / 2 + w, te = ka(I, z, x), Q = Ye(o) != null && z != te && n.reference[g] / 2 - (z < I ? F : S) - B[g] / 2 < 0 ? z < I ? I - z : x - z : 0;
  return { [c]: p[c] - Q, data: { [c]: te, centerOffset: z - te + Q } };
} });
var Po = ["top", "right", "bottom", "left"];
var ml = Po.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
var Ls = { left: "right", right: "left", bottom: "top", top: "bottom" };
function aa(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Ls[t]);
}
function Eo(e, t, l) {
  l === void 0 && (l = false);
  const a = Ye(e), o = Ct(e), n = Ka(o);
  let s = o === "x" ? a === (l ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (s = aa(s)), { main: s, cross: aa(s) };
}
var Ns = { start: "end", end: "start" };
function Jt(e) {
  return e.replace(/start|end/g, (t) => Ns[t]);
}
var zs = function(e) {
  return e === void 0 && (e = {}), { name: "autoPlacement", options: e, async fn(t) {
    var l, a, o;
    const { rects: n, middlewareData: s, placement: r, platform: u, elements: f } = t, { crossAxis: v = false, alignment: p, allowedPlacements: c = ml, autoAlignment: g = true, ...B } = it(e, t), m = p !== void 0 || c === ml ? function(S, I, x) {
      return (S ? [...x.filter((z) => Ye(z) === S), ...x.filter((z) => Ye(z) !== S)] : x.filter((z) => Ge(z) === z)).filter((z) => !S || Ye(z) === S || !!I && Jt(z) !== z);
    }(p || null, g, c) : c, V = await Lt(t, B), b = ((l = s.autoPlacement) == null ? void 0 : l.index) || 0, T = m[b];
    if (T == null)
      return {};
    const { main: _, cross: h2 } = Eo(T, n, await (u.isRTL == null ? void 0 : u.isRTL(f.floating)));
    if (r !== T)
      return { reset: { placement: m[0] } };
    const k = [V[Ge(T)], V[_], V[h2]], C = [...((a = s.autoPlacement) == null ? void 0 : a.overflows) || [], { placement: T, overflows: k }], w = m[b + 1];
    if (w)
      return { data: { index: b + 1, overflows: C }, reset: { placement: w } };
    const P = C.map((S) => {
      const I = Ye(S.placement);
      return [S.placement, I && v ? S.overflows.slice(0, 2).reduce((x, z) => x + z, 0) : S.overflows[0], S.overflows];
    }).sort((S, I) => S[1] - I[1]), F = ((o = P.filter((S) => S[2].slice(0, Ye(S[0]) ? 2 : 3).every((I) => I <= 0))[0]) == null ? void 0 : o[0]) || P[0][0];
    return F !== r ? { data: { index: b + 1, overflows: C }, reset: { placement: F } } : {};
  } };
};
var Fo = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var l;
    const { placement: a, middlewareData: o, rects: n, initialPlacement: s, platform: r, elements: u } = t, { mainAxis: f = true, crossAxis: v = true, fallbackPlacements: p, fallbackStrategy: c = "bestFit", fallbackAxisSideDirection: g = "none", flipAlignment: B = true, ...m } = it(e, t), V = Ge(a), b = Ge(s) === s, T = await (r.isRTL == null ? void 0 : r.isRTL(u.floating)), _ = p || (b || !B ? [aa(s)] : function(I) {
      const x = aa(I);
      return [Jt(I), x, Jt(x)];
    }(s));
    p || g === "none" || _.push(...function(I, x, z, te) {
      const Q = Ye(I);
      let G = function(X, U, pe) {
        const be = ["left", "right"], he = ["right", "left"], ye = ["top", "bottom"], q = ["bottom", "top"];
        switch (X) {
          case "top":
          case "bottom":
            return pe ? U ? he : be : U ? be : he;
          case "left":
          case "right":
            return U ? ye : q;
          default:
            return [];
        }
      }(Ge(I), z === "start", te);
      return Q && (G = G.map((X) => X + "-" + Q), x && (G = G.concat(G.map(Jt)))), G;
    }(s, B, g, T));
    const h2 = [s, ..._], k = await Lt(t, m), C = [];
    let w = ((l = o.flip) == null ? void 0 : l.overflows) || [];
    if (f && C.push(k[V]), v) {
      const { main: I, cross: x } = Eo(a, n, T);
      C.push(k[I], k[x]);
    }
    if (w = [...w, { placement: a, overflows: C }], !C.every((I) => I <= 0)) {
      var P, F;
      const I = (((P = o.flip) == null ? void 0 : P.index) || 0) + 1, x = h2[I];
      if (x)
        return { data: { index: I, overflows: w }, reset: { placement: x } };
      let z = (F = w.filter((te) => te.overflows[0] <= 0).sort((te, Q) => te.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : F.placement;
      if (!z)
        switch (c) {
          case "bestFit": {
            var S;
            const te = (S = w.map((Q) => [Q.placement, Q.overflows.filter((G) => G > 0).reduce((G, X) => G + X, 0)]).sort((Q, G) => Q[1] - G[1])[0]) == null ? void 0 : S[0];
            te && (z = te);
            break;
          }
          case "initialPlacement":
            z = s;
        }
      if (a !== z)
        return { reset: { placement: z } };
    }
    return {};
  } };
};
function gl(e, t) {
  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };
}
function yl(e) {
  return Po.some((t) => e[t] >= 0);
}
var Hs = function(e) {
  return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) {
    const { rects: l } = t, { strategy: a = "referenceHidden", ...o } = it(e, t);
    switch (a) {
      case "referenceHidden": {
        const n = gl(await Lt(t, { ...o, elementContext: "reference" }), l.reference);
        return { data: { referenceHiddenOffsets: n, referenceHidden: yl(n) } };
      }
      case "escaped": {
        const n = gl(await Lt(t, { ...o, altBoundary: true }), l.floating);
        return { data: { escapedOffsets: n, escaped: yl(n) } };
      }
      default:
        return {};
    }
  } };
};
function bl(e) {
  const t = wt(...e.map((a) => a.left)), l = wt(...e.map((a) => a.top));
  return { x: t, y: l, width: ta(...e.map((a) => a.right)) - t, height: ta(...e.map((a) => a.bottom)) - l };
}
var Rs = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: l, elements: a, rects: o, platform: n, strategy: s } = t, { padding: r = 2, x: u, y: f } = it(e, t), v = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(a.reference)) || []), p = function(m) {
      const V = m.slice().sort((_, h2) => _.y - h2.y), b = [];
      let T = null;
      for (let _ = 0; _ < V.length; _++) {
        const h2 = V[_];
        !T || h2.y - T.y > T.height / 2 ? b.push([h2]) : b[b.length - 1].push(h2), T = h2;
      }
      return b.map((_) => _t(bl(_)));
    }(v), c = _t(bl(v)), g = Xa(r), B = await n.getElementRects({ reference: { getBoundingClientRect: function() {
      if (p.length === 2 && p[0].left > p[1].right && u != null && f != null)
        return p.find((m) => u > m.left - g.left && u < m.right + g.right && f > m.top - g.top && f < m.bottom + g.bottom) || c;
      if (p.length >= 2) {
        if (Ct(l) === "x") {
          const k = p[0], C = p[p.length - 1], w = Ge(l) === "top", P = k.top, F = C.bottom, S = w ? k.left : C.left, I = w ? k.right : C.right;
          return { top: P, bottom: F, left: S, right: I, width: I - S, height: F - P, x: S, y: P };
        }
        const m = Ge(l) === "left", V = ta(...p.map((k) => k.right)), b = wt(...p.map((k) => k.left)), T = p.filter((k) => m ? k.left === b : k.right === V), _ = T[0].top, h2 = T[T.length - 1].bottom;
        return { top: _, bottom: h2, left: b, right: V, width: V - b, height: h2 - _, x: b, y: _ };
      }
      return c;
    } }, floating: a.floating, strategy: s });
    return o.reference.x !== B.reference.x || o.reference.y !== B.reference.y || o.reference.width !== B.reference.width || o.reference.height !== B.reference.height ? { reset: { rects: B } } : {};
  } };
};
var Io = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: l, y: a } = t, o = await async function(n, s) {
      const { placement: r, platform: u, elements: f } = n, v = await (u.isRTL == null ? void 0 : u.isRTL(f.floating)), p = Ge(r), c = Ye(r), g = Ct(r) === "x", B = ["left", "top"].includes(p) ? -1 : 1, m = v && g ? -1 : 1, V = it(s, n);
      let { mainAxis: b, crossAxis: T, alignmentAxis: _ } = typeof V == "number" ? { mainAxis: V, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...V };
      return c && typeof _ == "number" && (T = c === "end" ? -1 * _ : _), g ? { x: T * m, y: b * B } : { x: b * B, y: T * m };
    }(t, e);
    return { x: l + o.x, y: a + o.y, data: o };
  } };
};
function Ms(e) {
  return e === "x" ? "y" : "x";
}
var xo = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: l, y: a, placement: o } = t, { mainAxis: n = true, crossAxis: s = false, limiter: r = { fn: (V) => {
      let { x: b, y: T } = V;
      return { x: b, y: T };
    } }, ...u } = it(e, t), f = { x: l, y: a }, v = await Lt(t, u), p = Ct(Ge(o)), c = Ms(p);
    let g = f[p], B = f[c];
    if (n) {
      const V = p === "y" ? "bottom" : "right";
      g = ka(g + v[p === "y" ? "top" : "left"], g, g - v[V]);
    }
    if (s) {
      const V = c === "y" ? "bottom" : "right";
      B = ka(B + v[c === "y" ? "top" : "left"], B, B - v[V]);
    }
    const m = r.fn({ ...t, [p]: g, [c]: B });
    return { ...m, data: { x: m.x - l, y: m.y - a } };
  } };
};
function je(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function We(e) {
  return je(e).getComputedStyle(e);
}
function Lo(e) {
  return e instanceof je(e).Node;
}
function st(e) {
  return Lo(e) ? (e.nodeName || "").toLowerCase() : "";
}
function Ue(e) {
  return e instanceof je(e).HTMLElement;
}
function Ne(e) {
  return e instanceof je(e).Element;
}
function hl(e) {
  return typeof ShadowRoot > "u" ? false : e instanceof je(e).ShadowRoot || e instanceof ShadowRoot;
}
function Nt(e) {
  const { overflow: t, overflowX: l, overflowY: a, display: o } = We(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + l) && !["inline", "contents"].includes(o);
}
function Ds(e) {
  return ["table", "td", "th"].includes(st(e));
}
function Ca(e) {
  const t = Ya(), l = We(e);
  return l.transform !== "none" || l.perspective !== "none" || !t && !!l.backdropFilter && l.backdropFilter !== "none" || !t && !!l.filter && l.filter !== "none" || ["transform", "perspective", "filter"].some((a) => (l.willChange || "").includes(a)) || ["paint", "layout", "strict", "content"].some((a) => (l.contain || "").includes(a));
}
function Ya() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function va(e) {
  return ["html", "body", "#document"].includes(st(e));
}
var Bl = Math.min;
var Ft = Math.max;
var la = Math.round;
function No(e) {
  const t = We(e);
  let l = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const o = Ue(e), n = o ? e.offsetWidth : l, s = o ? e.offsetHeight : a, r = la(l) !== n || la(a) !== s;
  return r && (l = n, a = s), { width: l, height: a, fallback: r };
}
function zo(e) {
  return Ne(e) ? e : e.contextElement;
}
var Ho = { x: 1, y: 1 };
function ht(e) {
  const t = zo(e);
  if (!Ue(t))
    return Ho;
  const l = t.getBoundingClientRect(), { width: a, height: o, fallback: n } = No(t);
  let s = (n ? la(l.width) : l.width) / a, r = (n ? la(l.height) : l.height) / o;
  return s && Number.isFinite(s) || (s = 1), r && Number.isFinite(r) || (r = 1), { x: s, y: r };
}
var Sl = { x: 0, y: 0 };
function Ro(e, t, l) {
  var a, o;
  if (t === void 0 && (t = true), !Ya())
    return Sl;
  const n = e ? je(e) : window;
  return !l || t && l !== n ? Sl : { x: ((a = n.visualViewport) == null ? void 0 : a.offsetLeft) || 0, y: ((o = n.visualViewport) == null ? void 0 : o.offsetTop) || 0 };
}
function dt(e, t, l, a) {
  t === void 0 && (t = false), l === void 0 && (l = false);
  const o = e.getBoundingClientRect(), n = zo(e);
  let s = Ho;
  t && (a ? Ne(a) && (s = ht(a)) : s = ht(e));
  const r = Ro(n, l, a);
  let u = (o.left + r.x) / s.x, f = (o.top + r.y) / s.y, v = o.width / s.x, p = o.height / s.y;
  if (n) {
    const c = je(n), g = a && Ne(a) ? je(a) : a;
    let B = c.frameElement;
    for (; B && a && g !== c; ) {
      const m = ht(B), V = B.getBoundingClientRect(), b = getComputedStyle(B);
      V.x += (B.clientLeft + parseFloat(b.paddingLeft)) * m.x, V.y += (B.clientTop + parseFloat(b.paddingTop)) * m.y, u *= m.x, f *= m.y, v *= m.x, p *= m.y, u += V.x, f += V.y, B = je(B).frameElement;
    }
  }
  return _t({ width: v, height: p, x: u, y: f });
}
function nt(e) {
  return ((Lo(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function pa(e) {
  return Ne(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function Mo(e) {
  return dt(nt(e)).left + pa(e).scrollLeft;
}
function $t(e) {
  if (st(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || hl(e) && e.host || nt(e);
  return hl(t) ? t.host : t;
}
function Do(e) {
  const t = $t(e);
  return va(t) ? t.ownerDocument.body : Ue(t) && Nt(t) ? t : Do(t);
}
function It(e, t) {
  var l;
  t === void 0 && (t = []);
  const a = Do(e), o = a === ((l = e.ownerDocument) == null ? void 0 : l.body), n = je(a);
  return o ? t.concat(n, n.visualViewport || [], Nt(a) ? a : []) : t.concat(a, It(a));
}
function _l(e, t, l) {
  let a;
  if (t === "viewport")
    a = function(o, n) {
      const s = je(o), r = nt(o), u = s.visualViewport;
      let f = r.clientWidth, v = r.clientHeight, p = 0, c = 0;
      if (u) {
        f = u.width, v = u.height;
        const g = Ya();
        (!g || g && n === "fixed") && (p = u.offsetLeft, c = u.offsetTop);
      }
      return { width: f, height: v, x: p, y: c };
    }(e, l);
  else if (t === "document")
    a = function(o) {
      const n = nt(o), s = pa(o), r = o.ownerDocument.body, u = Ft(n.scrollWidth, n.clientWidth, r.scrollWidth, r.clientWidth), f = Ft(n.scrollHeight, n.clientHeight, r.scrollHeight, r.clientHeight);
      let v = -s.scrollLeft + Mo(o);
      const p = -s.scrollTop;
      return We(r).direction === "rtl" && (v += Ft(n.clientWidth, r.clientWidth) - u), { width: u, height: f, x: v, y: p };
    }(nt(e));
  else if (Ne(t))
    a = function(o, n) {
      const s = dt(o, true, n === "fixed"), r = s.top + o.clientTop, u = s.left + o.clientLeft, f = Ue(o) ? ht(o) : { x: 1, y: 1 };
      return { width: o.clientWidth * f.x, height: o.clientHeight * f.y, x: u * f.x, y: r * f.y };
    }(t, l);
  else {
    const o = Ro(e);
    a = { ...t, x: t.x - o.x, y: t.y - o.y };
  }
  return _t(a);
}
function jo(e, t) {
  const l = $t(e);
  return !(l === t || !Ne(l) || va(l)) && (We(l).position === "fixed" || jo(l, t));
}
function wl(e, t) {
  return Ue(e) && We(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function $l(e, t) {
  const l = je(e);
  if (!Ue(e))
    return l;
  let a = wl(e, t);
  for (; a && Ds(a) && We(a).position === "static"; )
    a = wl(a, t);
  return a && (st(a) === "html" || st(a) === "body" && We(a).position === "static" && !Ca(a)) ? l : a || function(o) {
    let n = $t(o);
    for (; Ue(n) && !va(n); ) {
      if (Ca(n))
        return n;
      n = $t(n);
    }
    return null;
  }(e) || l;
}
function js(e, t, l) {
  const a = Ue(t), o = nt(t), n = l === "fixed", s = dt(e, true, n, t);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const u = { x: 0, y: 0 };
  if (a || !a && !n)
    if ((st(t) !== "body" || Nt(o)) && (r = pa(t)), Ue(t)) {
      const f = dt(t, true, n, t);
      u.x = f.x + t.clientLeft, u.y = f.y + t.clientTop;
    } else
      o && (u.x = Mo(o));
  return { x: s.left + r.scrollLeft - u.x, y: s.top + r.scrollTop - u.y, width: s.width, height: s.height };
}
var qs = { getClippingRect: function(e) {
  let { element: t, boundary: l, rootBoundary: a, strategy: o } = e;
  const n = l === "clippingAncestors" ? function(f, v) {
    const p = v.get(f);
    if (p)
      return p;
    let c = It(f).filter((V) => Ne(V) && st(V) !== "body"), g = null;
    const B = We(f).position === "fixed";
    let m = B ? $t(f) : f;
    for (; Ne(m) && !va(m); ) {
      const V = We(m), b = Ca(m);
      b || V.position !== "fixed" || (g = null), (B ? !b && !g : !b && V.position === "static" && g && ["absolute", "fixed"].includes(g.position) || Nt(m) && !b && jo(f, m)) ? c = c.filter((T) => T !== m) : g = V, m = $t(m);
    }
    return v.set(f, c), c;
  }(t, this._c) : [].concat(l), s = [...n, a], r = s[0], u = s.reduce((f, v) => {
    const p = _l(t, v, o);
    return f.top = Ft(p.top, f.top), f.right = Bl(p.right, f.right), f.bottom = Bl(p.bottom, f.bottom), f.left = Ft(p.left, f.left), f;
  }, _l(t, r, o));
  return { width: u.right - u.left, height: u.bottom - u.top, x: u.left, y: u.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: l, strategy: a } = e;
  const o = Ue(l), n = nt(l);
  if (l === n)
    return t;
  let s = { scrollLeft: 0, scrollTop: 0 }, r = { x: 1, y: 1 };
  const u = { x: 0, y: 0 };
  if ((o || !o && a !== "fixed") && ((st(l) !== "body" || Nt(n)) && (s = pa(l)), Ue(l))) {
    const f = dt(l);
    r = ht(l), u.x = f.x + l.clientLeft, u.y = f.y + l.clientTop;
  }
  return { width: t.width * r.x, height: t.height * r.y, x: t.x * r.x - s.scrollLeft * r.x + u.x, y: t.y * r.y - s.scrollTop * r.y + u.y };
}, isElement: Ne, getDimensions: function(e) {
  return No(e);
}, getOffsetParent: $l, getDocumentElement: nt, getScale: ht, async getElementRects(e) {
  let { reference: t, floating: l, strategy: a } = e;
  const o = this.getOffsetParent || $l, n = this.getDimensions;
  return { reference: js(t, await o(l), a), floating: { x: 0, y: 0, ...await n(l) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => We(e).direction === "rtl" };
function Gs(e, t, l, a) {
  a === void 0 && (a = {});
  const { ancestorScroll: o = true, ancestorResize: n = true, elementResize: s = true, animationFrame: r = false } = a, u = o || n ? [...Ne(e) ? It(e) : e.contextElement ? It(e.contextElement) : [], ...It(t)] : [];
  u.forEach((c) => {
    const g = !Ne(c) && c.toString().includes("V");
    !o || r && !g || c.addEventListener("scroll", l, { passive: true }), n && c.addEventListener("resize", l);
  });
  let f, v = null;
  s && (v = new ResizeObserver(() => {
    l();
  }), Ne(e) && !r && v.observe(e), Ne(e) || !e.contextElement || r || v.observe(e.contextElement), v.observe(t));
  let p = r ? dt(e) : null;
  return r && function c() {
    const g = dt(e);
    !p || g.x === p.x && g.y === p.y && g.width === p.width && g.height === p.height || l(), p = g, f = requestAnimationFrame(c);
  }(), l(), () => {
    var c;
    u.forEach((g) => {
      o && g.removeEventListener("scroll", l), n && g.removeEventListener("resize", l);
    }), (c = v) == null || c.disconnect(), v = null, r && cancelAnimationFrame(f);
  };
}
var Ws = (e, t, l) => {
  const a = /* @__PURE__ */ new Map(), o = { platform: qs, ...l }, n = { ...o.platform, _c: a };
  return Is(e, t, { ...o, platform: n });
};
function Ta(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function Us(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const l = Ta(unref(e.element));
      return l == null ? {} : xs({
        element: l,
        padding: e.padding
      }).fn(t);
    }
  };
}
function qo(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function kl(e, t) {
  const l = qo(e);
  return Math.round(t * l) / l;
}
function Go(e, t, l) {
  l === void 0 && (l = {});
  const a = l.whileElementsMounted, o = computed(() => {
    var w;
    return (w = unref(l.open)) != null ? w : true;
  }), n = computed(() => unref(l.middleware)), s = computed(() => {
    var w;
    return (w = unref(l.placement)) != null ? w : "bottom";
  }), r = computed(() => {
    var w;
    return (w = unref(l.strategy)) != null ? w : "absolute";
  }), u = computed(() => {
    var w;
    return (w = unref(l.transform)) != null ? w : true;
  }), f = computed(() => Ta(e.value)), v = computed(() => Ta(t.value)), p = ref(0), c = ref(0), g = ref(r.value), B = ref(s.value), m = shallowRef({}), V = ref(false), b = computed(() => {
    const w = {
      position: g.value,
      left: "0",
      top: "0"
    };
    if (!v.value)
      return w;
    const P = kl(v.value, p.value), F = kl(v.value, c.value);
    return u.value ? {
      ...w,
      transform: "translate(" + P + "px, " + F + "px)",
      ...qo(v.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: g.value,
      left: P + "px",
      top: F + "px"
    };
  });
  let T;
  function _() {
    f.value == null || v.value == null || Ws(f.value, v.value, {
      middleware: n.value,
      placement: s.value,
      strategy: r.value
    }).then((w) => {
      p.value = w.x, c.value = w.y, g.value = w.strategy, B.value = w.placement, m.value = w.middlewareData, V.value = true;
    });
  }
  function h2() {
    typeof T == "function" && (T(), T = void 0);
  }
  function k() {
    if (h2(), a === void 0) {
      _();
      return;
    }
    if (f.value != null && v.value != null) {
      T = a(f.value, v.value, _);
      return;
    }
  }
  function C() {
    o.value || (V.value = false);
  }
  return watch([n, s, r], _, {
    flush: "sync"
  }), watch([f, v], k, {
    flush: "sync"
  }), watch(o, C, {
    flush: "sync"
  }), getCurrentScope() && onScopeDispose(h2), {
    x: shallowReadonly(p),
    y: shallowReadonly(c),
    strategy: shallowReadonly(g),
    placement: shallowReadonly(B),
    middlewareData: shallowReadonly(m),
    isPositioned: shallowReadonly(V),
    floatingStyles: b,
    update: _
  };
}
var Ks = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]);
var Xs = /^aria-[\w-]*$/i;
var Ys = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
var Js = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
var Zs = (e, t) => {
  const l = e.nodeName.toLowerCase();
  return t.includes(l) ? Ks.has(l) ? !!(Ys.test(e.nodeValue || "") || Js.test(e.nodeValue || "")) : true : t.filter((a) => a instanceof RegExp).some((a) => a.test(l));
};
var gt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Xs],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
var yt = (e, t, l) => {
  if (!e.length)
    return e;
  if (l && typeof l == "function")
    return l(e);
  const o = new window.DOMParser().parseFromString(e, "text/html"), n = o.body.querySelectorAll("*");
  for (const s of n) {
    const r = s.nodeName.toLowerCase();
    if (!Object.keys(t).includes(r)) {
      s.remove();
      continue;
    }
    const u = s.attributes, f = [...t["*"] || [], ...t[r] || []];
    for (const v of u)
      Zs(v, f) || s.removeAttribute(v.nodeName);
  }
  return o.body.innerHTML;
};
var Qs = Object.defineProperty;
var er = Object.defineProperties;
var tr = Object.getOwnPropertyDescriptors;
var Cl = Object.getOwnPropertySymbols;
var ar = Object.prototype.hasOwnProperty;
var lr = Object.prototype.propertyIsEnumerable;
var Tl = (e, t, l) => t in e ? Qs(e, t, { enumerable: true, configurable: true, writable: true, value: l }) : e[t] = l;
var or = (e, t) => {
  for (var l in t || (t = {}))
    ar.call(t, l) && Tl(e, l, t[l]);
  if (Cl)
    for (var l of Cl(t))
      lr.call(t, l) && Tl(e, l, t[l]);
  return e;
};
var nr = (e, t) => er(e, tr(t));
function Wo(e, t) {
  var l;
  const a = shallowRef();
  return watchEffect(() => {
    a.value = e();
  }, nr(or({}, t), {
    flush: (l = t == null ? void 0 : t.flush) != null ? l : "sync"
  })), readonly(a);
}
function ct(e) {
  return getCurrentScope() ? (onScopeDispose(e), true) : false;
}
function sr(e) {
  let t = false, l;
  const a = effectScope(true);
  return (...o) => (t || (l = a.run(() => e(...o)), t = true), l);
}
function rr(e) {
  let t = 0, l, a;
  const o = () => {
    t -= 1, a && t <= 0 && (a.stop(), l = void 0, a = void 0);
  };
  return (...n) => (t += 1, l || (a = effectScope(true), l = a.run(() => e(...n))), ct(o), l);
}
function ft(e) {
  return typeof e == "function" ? e() : unref(e);
}
var oa = typeof window < "u";
var ir = (e) => typeof e < "u";
var zt = () => {
};
var Va = ur();
function ur() {
  var e;
  return oa && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function dr(e, t) {
  function l(...a) {
    return new Promise((o, n) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(o).catch(n);
    });
  }
  return l;
}
var Uo = (e) => e();
function cr(e = Uo) {
  const t = ref(true);
  function l() {
    t.value = false;
  }
  function a() {
    t.value = true;
  }
  const o = (...n) => {
    t.value && e(...n);
  };
  return { isActive: readonly(t), pause: l, resume: a, eventFilter: o };
}
function Ja(...e) {
  if (e.length !== 1)
    return toRef(...e);
  const t = e[0];
  return typeof t == "function" ? readonly(customRef(() => ({ get: t, set: zt }))) : ref(t);
}
function fr(e, t = true) {
  getCurrentInstance() ? onMounted(e) : t ? e() : nextTick(e);
}
function vr(e = 0, t = {}) {
  const l = ref(e), {
    max: a = 1 / 0,
    min: o = -1 / 0
  } = t, n = (v = 1) => l.value = Math.min(a, l.value + v), s = (v = 1) => l.value = Math.max(o, l.value - v), r = () => l.value, u = (v) => l.value = Math.max(o, Math.min(a, v));
  return { count: l, inc: n, dec: s, get: r, set: u, reset: (v = e) => (e = v, u(v)) };
}
function Ko(e, t = 1e3, l = {}) {
  const {
    immediate: a = true,
    immediateCallback: o = false
  } = l;
  let n = null;
  const s = ref(false);
  function r() {
    n && (clearInterval(n), n = null);
  }
  function u() {
    s.value = false, r();
  }
  function f() {
    const v = ft(t);
    v <= 0 || (s.value = true, o && e(), r(), n = setInterval(e, v));
  }
  if (a && oa && f(), isRef(t) || typeof t == "function") {
    const v = watch(t, () => {
      s.value && oa && f();
    });
    ct(v);
  }
  return ct(u), {
    isActive: s,
    pause: u,
    resume: f
  };
}
function bt(e, t = {}) {
  const {
    method: l = "parseFloat",
    radix: a,
    nanToZero: o
  } = t;
  return computed(() => {
    let n = ft(e);
    return typeof n == "string" && (n = Number[l](n, a)), o && Number.isNaN(n) && (n = 0), n;
  });
}
var Vl = Object.getOwnPropertySymbols;
var pr = Object.prototype.hasOwnProperty;
var mr = Object.prototype.propertyIsEnumerable;
var gr = (e, t) => {
  var l = {};
  for (var a in e)
    pr.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);
  if (e != null && Vl)
    for (var a of Vl(e))
      t.indexOf(a) < 0 && mr.call(e, a) && (l[a] = e[a]);
  return l;
};
function yr(e, t, l = {}) {
  const a = l, {
    eventFilter: o = Uo
  } = a, n = gr(a, [
    "eventFilter"
  ]);
  return watch(
    e,
    dr(
      o,
      t
    ),
    n
  );
}
var br = Object.defineProperty;
var hr = Object.defineProperties;
var Br = Object.getOwnPropertyDescriptors;
var na = Object.getOwnPropertySymbols;
var Xo = Object.prototype.hasOwnProperty;
var Yo = Object.prototype.propertyIsEnumerable;
var Ol = (e, t, l) => t in e ? br(e, t, { enumerable: true, configurable: true, writable: true, value: l }) : e[t] = l;
var Sr = (e, t) => {
  for (var l in t || (t = {}))
    Xo.call(t, l) && Ol(e, l, t[l]);
  if (na)
    for (var l of na(t))
      Yo.call(t, l) && Ol(e, l, t[l]);
  return e;
};
var _r = (e, t) => hr(e, Br(t));
var wr = (e, t) => {
  var l = {};
  for (var a in e)
    Xo.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);
  if (e != null && na)
    for (var a of na(e))
      t.indexOf(a) < 0 && Yo.call(e, a) && (l[a] = e[a]);
  return l;
};
function $r(e, t, l = {}) {
  const a = l, {
    eventFilter: o
  } = a, n = wr(a, [
    "eventFilter"
  ]), { eventFilter: s, pause: r, resume: u, isActive: f } = cr(o);
  return { stop: yr(
    e,
    t,
    _r(Sr({}, n), {
      eventFilter: s
    })
  ), pause: r, resume: u, isActive: f };
}
function et(e) {
  var t;
  const l = ft(e);
  return (t = l == null ? void 0 : l.$el) != null ? t : l;
}
var tt = oa ? window : void 0;
function Te(...e) {
  let t, l, a, o;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([l, a, o] = e, t = tt) : [t, l, a, o] = e, !t)
    return zt;
  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);
  const n = [], s = () => {
    n.forEach((v) => v()), n.length = 0;
  }, r = (v, p, c, g) => (v.addEventListener(p, c, g), () => v.removeEventListener(p, c, g)), u = watch(
    () => [et(t), ft(o)],
    ([v, p]) => {
      s(), v && n.push(
        ...l.flatMap((c) => a.map((g) => r(v, c, g, p)))
      );
    },
    { immediate: true, flush: "post" }
  ), f = () => {
    u(), s();
  };
  return ct(f), f;
}
var Al = false;
function Jo(e, t, l = {}) {
  const { window: a = tt, ignore: o = [], capture: n = true, detectIframe: s = false } = l;
  if (!a)
    return;
  Va && !Al && (Al = true, Array.from(a.document.body.children).forEach((c) => c.addEventListener("click", zt)));
  let r = true;
  const u = (c) => o.some((g) => {
    if (typeof g == "string")
      return Array.from(a.document.querySelectorAll(g)).some((B) => B === c.target || c.composedPath().includes(B));
    {
      const B = et(g);
      return B && (c.target === B || c.composedPath().includes(B));
    }
  }), v = [
    Te(a, "click", (c) => {
      const g = et(e);
      if (!(!g || g === c.target || c.composedPath().includes(g))) {
        if (c.detail === 0 && (r = !u(c)), !r) {
          r = true;
          return;
        }
        t(c);
      }
    }, { passive: true, capture: n }),
    Te(a, "pointerdown", (c) => {
      const g = et(e);
      g && (r = !c.composedPath().includes(g) && !u(c));
    }, { passive: true }),
    s && Te(a, "blur", (c) => {
      setTimeout(() => {
        var g;
        const B = et(e);
        ((g = a.document.activeElement) == null ? void 0 : g.tagName) === "IFRAME" && !(B != null && B.contains(a.document.activeElement)) && t(c);
      }, 0);
    })
  ].filter(Boolean);
  return () => v.forEach((c) => c());
}
function kr() {
  const e = ref(false);
  return getCurrentInstance() && onMounted(() => {
    e.value = true;
  }), e;
}
function Cr(e) {
  const t = kr();
  return computed(() => (t.value, !!e()));
}
function Tr(e, t = {}) {
  const { window: l = tt } = t, a = Cr(() => l && "matchMedia" in l && typeof l.matchMedia == "function");
  let o;
  const n = ref(false), s = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", r) : o.removeListener(r));
  }, r = () => {
    a.value && (s(), o = l.matchMedia(Ja(e).value), n.value = !!(o != null && o.matches), o && ("addEventListener" in o ? o.addEventListener("change", r) : o.addListener(r)));
  };
  return watchEffect(r), ct(() => s()), n;
}
function Vr(e) {
  return JSON.parse(JSON.stringify(e));
}
var Wt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Ut = "__vueuse_ssr_handlers__";
var Or = Ar();
function Ar() {
  return Ut in Wt || (Wt[Ut] = Wt[Ut] || {}), Wt[Ut];
}
function Za(e, t) {
  return Or[e] || t;
}
function Pr(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
var Er = Object.defineProperty;
var Pl = Object.getOwnPropertySymbols;
var Fr = Object.prototype.hasOwnProperty;
var Ir = Object.prototype.propertyIsEnumerable;
var El = (e, t, l) => t in e ? Er(e, t, { enumerable: true, configurable: true, writable: true, value: l }) : e[t] = l;
var Fl = (e, t) => {
  for (var l in t || (t = {}))
    Fr.call(t, l) && El(e, l, t[l]);
  if (Pl)
    for (var l of Pl(t))
      Ir.call(t, l) && El(e, l, t[l]);
  return e;
};
var xr = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
};
var Il = "vueuse-storage";
function Lr(e, t, l, a = {}) {
  var o;
  const {
    flush: n = "pre",
    deep: s = true,
    listenToStorageChanges: r = true,
    writeDefaults: u = true,
    mergeDefaults: f = false,
    shallow: v,
    window: p = tt,
    eventFilter: c,
    onError: g = (P) => {
      console.error(P);
    }
  } = a, B = (v ? shallowRef : ref)(t);
  if (!l)
    try {
      l = Za("getDefaultStorage", () => {
        var P;
        return (P = tt) == null ? void 0 : P.localStorage;
      })();
    } catch (P) {
      g(P);
    }
  if (!l)
    return B;
  const m = ft(t), V = Pr(m), b = (o = a.serializer) != null ? o : xr[V], { pause: T, resume: _ } = $r(
    B,
    () => h2(B.value),
    { flush: n, deep: s, eventFilter: c }
  );
  return p && r && (Te(p, "storage", w), Te(p, Il, C)), w(), B;
  function h2(P) {
    try {
      if (P == null)
        l.removeItem(e);
      else {
        const F = b.write(P), S = l.getItem(e);
        S !== F && (l.setItem(e, F), p && p.dispatchEvent(new CustomEvent(Il, {
          detail: {
            key: e,
            oldValue: S,
            newValue: F,
            storageArea: l
          }
        })));
      }
    } catch (F) {
      g(F);
    }
  }
  function k(P) {
    const F = P ? P.newValue : l.getItem(e);
    if (F == null)
      return u && m !== null && l.setItem(e, b.write(m)), m;
    if (!P && f) {
      const S = b.read(F);
      return typeof f == "function" ? f(S, m) : V === "object" && !Array.isArray(S) ? Fl(Fl({}, m), S) : S;
    } else
      return typeof F != "string" ? F : b.read(F);
  }
  function C(P) {
    w(P.detail);
  }
  function w(P) {
    if (!(P && P.storageArea !== l)) {
      if (P && P.key == null) {
        B.value = m;
        return;
      }
      if (!(P && P.key !== e)) {
        T();
        try {
          B.value = k(P);
        } catch (F) {
          g(F);
        } finally {
          P ? nextTick(_) : _();
        }
      }
    }
  }
}
function Nr(e) {
  return Tr("(prefers-color-scheme: dark)", e);
}
var zr = Object.defineProperty;
var xl = Object.getOwnPropertySymbols;
var Hr = Object.prototype.hasOwnProperty;
var Rr = Object.prototype.propertyIsEnumerable;
var Ll = (e, t, l) => t in e ? zr(e, t, { enumerable: true, configurable: true, writable: true, value: l }) : e[t] = l;
var Mr = (e, t) => {
  for (var l in t || (t = {}))
    Hr.call(t, l) && Ll(e, l, t[l]);
  if (xl)
    for (var l of xl(t))
      Rr.call(t, l) && Ll(e, l, t[l]);
  return e;
};
function Dr(e = {}) {
  const {
    selector: t = "html",
    attribute: l = "class",
    initialValue: a = "auto",
    window: o = tt,
    storage: n,
    storageKey: s = "vueuse-color-scheme",
    listenToStorageChanges: r = true,
    storageRef: u,
    emitAuto: f,
    disableTransition: v = true
  } = e, p = Mr({
    auto: "",
    light: "light",
    dark: "dark"
  }, e.modes || {}), c = Nr({ window: o }), g = computed(() => c.value ? "dark" : "light"), B = u || (s == null ? Ja(a) : Lr(s, a, n, { window: o, listenToStorageChanges: r })), m = computed(
    () => B.value === "auto" ? g.value : B.value
  ), V = Za(
    "updateHTMLAttrs",
    (h2, k, C) => {
      const w = typeof h2 == "string" ? o == null ? void 0 : o.document.querySelector(h2) : et(h2);
      if (!w)
        return;
      let P;
      if (v) {
        P = o.document.createElement("style");
        const F = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
        P.appendChild(document.createTextNode(F)), o.document.head.appendChild(P);
      }
      if (k === "class") {
        const F = C.split(/\s/g);
        Object.values(p).flatMap((S) => (S || "").split(/\s/g)).filter(Boolean).forEach((S) => {
          F.includes(S) ? w.classList.add(S) : w.classList.remove(S);
        });
      } else
        w.setAttribute(k, C);
      v && (o.getComputedStyle(P).opacity, document.head.removeChild(P));
    }
  );
  function b(h2) {
    var k;
    V(t, l, (k = p[h2]) != null ? k : h2);
  }
  function T(h2) {
    e.onChanged ? e.onChanged(h2, b) : b(h2);
  }
  watch(m, T, { flush: "post", immediate: true }), fr(() => T(m.value));
  const _ = computed({
    get() {
      return f ? B.value : m.value;
    },
    set(h2) {
      B.value = h2;
    }
  });
  try {
    return Object.assign(_, { store: B, system: g, state: m });
  } catch {
    return _;
  }
}
function ze(e, t = {}) {
  const { initialValue: l = false } = t, a = ref(false), o = computed(() => et(e));
  Te(o, "focus", () => a.value = true), Te(o, "blur", () => a.value = false);
  const n = computed({
    get: () => a.value,
    set(s) {
      var r, u;
      !s && a.value ? (r = o.value) == null || r.blur() : s && !a.value && ((u = o.value) == null || u.focus());
    }
  });
  return watch(
    o,
    () => {
      n.value = l;
    },
    { immediate: true, flush: "post" }
  ), { focused: n };
}
var jr = {
  page: (e) => [e.pageX, e.pageY],
  client: (e) => [e.clientX, e.clientY],
  screen: (e) => [e.screenX, e.screenY],
  movement: (e) => e instanceof Touch ? null : [e.movementX, e.movementY]
};
function qr(e = {}) {
  const {
    type: t = "page",
    touch: l = true,
    resetOnTouchEnds: a = false,
    initialValue: o = { x: 0, y: 0 },
    window: n = tt,
    target: s = n,
    eventFilter: r
  } = e, u = ref(o.x), f = ref(o.y), v = ref(null), p = typeof t == "function" ? t : jr[t], c = (b) => {
    const T = p(b);
    T && ([u.value, f.value] = T, v.value = "mouse");
  }, g = (b) => {
    if (b.touches.length > 0) {
      const T = p(b.touches[0]);
      T && ([u.value, f.value] = T, v.value = "touch");
    }
  }, B = () => {
    u.value = o.x, f.value = o.y;
  }, m = r ? (b) => r(() => c(b), {}) : (b) => c(b), V = r ? (b) => r(() => g(b), {}) : (b) => g(b);
  return s && (Te(s, "mousemove", m, { passive: true }), Te(s, "dragover", m, { passive: true }), l && t !== "movement" && (Te(s, "touchstart", V, { passive: true }), Te(s, "touchmove", V, { passive: true }), a && Te(s, "touchend", B, { passive: true }))), {
    x: u,
    y: f,
    sourceType: v
  };
}
function Nl(e, t = {}) {
  const {
    handleOutside: l = true,
    window: a = tt
  } = t, { x: o, y: n, sourceType: s } = qr(t), r = ref(e ?? (a == null ? void 0 : a.document.body)), u = ref(0), f = ref(0), v = ref(0), p = ref(0), c = ref(0), g = ref(0), B = ref(true);
  let m = () => {
  };
  return a && (m = watch(
    [r, o, n],
    () => {
      const V = et(r);
      if (!V)
        return;
      const {
        left: b,
        top: T,
        width: _,
        height: h2
      } = V.getBoundingClientRect();
      v.value = b + a.pageXOffset, p.value = T + a.pageYOffset, c.value = h2, g.value = _;
      const k = o.value - v.value, C = n.value - p.value;
      B.value = _ === 0 || h2 === 0 || k < 0 || C < 0 || k > _ || C > h2, (l || !B.value) && (u.value = k, f.value = C);
    },
    { immediate: true }
  ), Te(document, "mouseleave", () => {
    B.value = true;
  })), {
    x: o,
    y: n,
    sourceType: s,
    elementX: u,
    elementY: f,
    elementPositionX: v,
    elementPositionY: p,
    elementHeight: c,
    elementWidth: g,
    isOutside: B,
    stop: m
  };
}
function Zo(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return true;
  {
    const l = e.parentNode;
    return !l || l.tagName === "BODY" ? false : Zo(l);
  }
}
function Gr(e) {
  const t = e || window.event, l = t.target;
  return Zo(l) ? false : t.touches.length > 1 ? true : (t.preventDefault && t.preventDefault(), false);
}
function Wr(e, t = false) {
  const l = ref(t);
  let a = null, o;
  watch(Ja(e), (r) => {
    if (r) {
      const u = r;
      o = u.style.overflow, l.value && (u.style.overflow = "hidden");
    }
  }, {
    immediate: true
  });
  const n = () => {
    const r = ft(e);
    !r || l.value || (Va && (a = Te(
      r,
      "touchmove",
      (u) => {
        Gr(u);
      },
      { passive: false }
    )), r.style.overflow = "hidden", l.value = true);
  }, s = () => {
    const r = ft(e);
    !r || !l.value || (Va && (a == null || a()), r.style.overflow = o, l.value = false);
  };
  return ct(s), computed({
    get() {
      return l.value;
    },
    set(r) {
      r ? n() : s();
    }
  });
}
function Ur(e, t = {}) {
  const {
    threshold: l = 50,
    onSwipe: a,
    onSwipeEnd: o,
    onSwipeStart: n,
    passive: s = true,
    window: r = tt
  } = t, u = reactive({ x: 0, y: 0 }), f = reactive({ x: 0, y: 0 }), v = computed(() => u.x - f.x), p = computed(() => u.y - f.y), { max: c, abs: g } = Math, B = computed(() => c(g(v.value), g(p.value)) >= l), m = ref(false), V = computed(() => B.value ? g(v.value) > g(p.value) ? v.value > 0 ? "left" : "right" : p.value > 0 ? "up" : "down" : "none"), b = (F) => [F.touches[0].clientX, F.touches[0].clientY], T = (F, S) => {
    u.x = F, u.y = S;
  }, _ = (F, S) => {
    f.x = F, f.y = S;
  };
  let h2;
  const k = Kr(r == null ? void 0 : r.document);
  s ? h2 = k ? { passive: true } : { capture: false } : h2 = k ? { passive: false, capture: true } : { capture: true };
  const C = (F) => {
    m.value && (o == null || o(F, V.value)), m.value = false;
  }, w = [
    Te(e, "touchstart", (F) => {
      if (F.touches.length !== 1)
        return;
      h2.capture && !h2.passive && F.preventDefault();
      const [S, I] = b(F);
      T(S, I), _(S, I), n == null || n(F);
    }, h2),
    Te(e, "touchmove", (F) => {
      if (F.touches.length !== 1)
        return;
      const [S, I] = b(F);
      _(S, I), !m.value && B.value && (m.value = true), m.value && (a == null || a(F));
    }, h2),
    Te(e, "touchend", C, h2),
    Te(e, "touchcancel", C, h2)
  ];
  return {
    isPassiveEventSupported: k,
    isSwiping: m,
    direction: V,
    coordsStart: u,
    coordsEnd: f,
    lengthX: v,
    lengthY: p,
    stop: () => w.forEach((F) => F())
  };
}
function Kr(e) {
  if (!e)
    return false;
  let t = false;
  const l = {
    get passive() {
      return t = true, false;
    }
  };
  return e.addEventListener("x", zt, l), e.removeEventListener("x", zt), t;
}
function ke(e, t, l, a = {}) {
  var o, n, s;
  const {
    clone: r = false,
    passive: u = false,
    eventName: f,
    deep: v = false,
    defaultValue: p,
    shouldEmit: c
  } = a, g = getCurrentInstance(), B = l || (g == null ? void 0 : g.emit) || ((o = g == null ? void 0 : g.$emit) == null ? void 0 : o.bind(g)) || ((s = (n = g == null ? void 0 : g.proxy) == null ? void 0 : n.$emit) == null ? void 0 : s.bind(g == null ? void 0 : g.proxy));
  let m = f;
  t || (t = "modelValue"), m = m || `update:${t.toString()}`;
  const V = (_) => r ? typeof r == "function" ? r(_) : Vr(_) : _, b = () => ir(e[t]) ? V(e[t]) : p, T = (_) => {
    c ? c(_) && B(m, _) : B(m, _);
  };
  if (u) {
    const _ = b(), h2 = ref(_);
    return watch(
      () => e[t],
      (k) => h2.value = V(k)
    ), watch(
      h2,
      (k) => {
        (k !== e[t] || v) && T(k);
      },
      { deep: v }
    ), h2;
  } else
    return computed({
      get() {
        return b();
      },
      set(_) {
        T(_);
      }
    });
}
var Qa = defineComponent({
  name: "ComponentOrEmpty",
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: false
    }
  },
  setup(e, { slots: t, attrs: l }) {
    return () => {
      var a, o, n;
      return e.skip ? (a = t.default) == null ? void 0 : a.call(t) : e.tag === "Teleport" ? h(Teleport, { to: e.to }, [(o = t.default) == null ? void 0 : o.call(t)]) : h(e.tag, { ...l }, [(n = t.default) == null ? void 0 : n.call(t)]);
    };
  }
});
var jt = (e) => Wo(() => {
  const t = toValue(e);
  return t ? `justify-content-${t}` : "";
});
function d(e) {
  return Wo(() => {
    const t = toValue(e);
    return t == null ? t : Ma(t);
  });
}
var Qo = sr(() => {
  const e = reactive([]);
  return { items: e, reset: () => {
    e.splice(0, e.length);
  } };
});
var Xr = (e = {}) => {
  const t = e.persist ?? false, l = "data-bs-theme", a = "body";
  return Dr({
    attribute: l,
    selector: a,
    storageKey: t === true ? `bv-color-${e.attribute ?? l}-${e.selector ?? a}` : null,
    ...e
  });
};
var Yr = (e, t = ref(1e3), l = {}) => {
  const a = readonly(toRef(e)), o = readonly(toRef(t)), n = ref(false), s = ref(0), r = computed(() => Math.ceil(a.value / o.value)), u = computed(
    () => p.value || n.value ? Math.round(a.value - s.value * o.value) : 0
  ), { pause: f, resume: v, isActive: p } = Ko(
    () => {
      s.value = s.value + 1;
    },
    t,
    l
  ), c = () => {
    n.value = false, s.value = 0, v();
  }, g = () => {
    n.value = false, s.value = r.value;
  };
  watchEffect(() => {
    s.value > r.value && (s.value = r.value), s.value === r.value && f();
  }), watch([o, a], () => {
    g(), c();
  });
  const B = () => {
    p.value !== false && (n.value = true, f());
  }, m = () => {
    s.value !== r.value && (n.value = false, v());
  };
  return {
    isActive: readonly(p),
    isPaused: readonly(n),
    restart: c,
    stop: g,
    pause: B,
    resume: m,
    value: u
  };
};
var en = (e) => computed(() => {
  const t = toValue(e);
  return {
    "form-check": t.plain === false && t.button === false,
    "form-check-inline": t.inline === true,
    "form-switch": t.switch === true,
    [`form-control-${t.size}`]: t.size !== void 0 && t.size !== "md" && t.button === false
  };
});
var tn = (e) => computed(() => {
  const t = toValue(e);
  return {
    "form-check-input": t.plain === false && t.button === false,
    "is-valid": t.state === true,
    "is-invalid": t.state === false,
    "btn-check": t.button === true
  };
});
var an = (e) => computed(() => {
  const t = toValue(e);
  return {
    "form-check-label": t.plain === false && t.button === false,
    btn: t.button === true,
    [`btn-${t.buttonVariant}`]: t.button === true && t.buttonVariant !== void 0 && t.buttonVariant !== null,
    [`btn-${t.size}`]: t.button && t.size && t.size !== "md"
  };
});
var ln = (e) => computed(() => {
  const t = toValue(e);
  return {
    "aria-invalid": fa(t.ariaInvalid, t.state),
    "aria-required": t.required === true ? true : void 0
  };
});
var on = (e) => computed(() => {
  const t = toValue(e);
  return {
    "was-validated": t.validated === true,
    "btn-group": t.buttons === true && t.stacked === false,
    "btn-group-vertical": t.stacked === true && t.buttons === true,
    [`btn-group-${t.size}`]: t.size !== void 0
  };
});
var nn = (e, t) => {
  const l = ref(null);
  let a = null, o = true;
  const n = Ve(() => e.id, "input"), s = d(() => e.autofocus), r = d(() => e.disabled), u = d(() => e.lazy), f = d(() => e.lazyFormatter), v = d(() => e.number);
  d(() => e.plaintext), d(() => e.readonly), d(() => e.required);
  const p = d(() => e.state), c = d(() => e.trim), { focused: g } = ze(l, {
    initialValue: s.value
  }), B = (w, P, F = false) => (w = String(w), typeof e.formatter == "function" && (!f.value || F) ? (o = false, e.formatter(w, P)) : w), m = (w) => c.value ? w.trim() : v.value ? Number.parseFloat(w) : w, V = () => {
    s.value && (g.value = true);
  };
  onMounted(() => {
    l.value && (l.value.value = e.modelValue);
  }), onActivated(() => {
    nextTick(() => {
      V();
    });
  });
  const b = computed(
    () => fa(e.ariaInvalid, p.value)
  ), T = (w) => {
    const { value: P } = w.target, F = B(P, w);
    if (F === false || w.defaultPrevented) {
      w.preventDefault();
      return;
    }
    if (u.value)
      return;
    const S = m(F);
    e.modelValue !== S && (a = P, t("update:modelValue", S)), t("input", F);
  }, _ = (w) => {
    const { value: P } = w.target, F = B(P, w);
    if (F === false || w.defaultPrevented) {
      w.preventDefault();
      return;
    }
    if (!u.value)
      return;
    a = P, t("update:modelValue", F);
    const S = m(F);
    e.modelValue !== S && t("change", F);
  }, h2 = (w) => {
    if (t("blur", w), !u.value && !f.value)
      return;
    const { value: P } = w.target, F = B(P, w, true);
    a = P, t("update:modelValue", F);
  }, k = () => {
    r.value || (g.value = true);
  }, C = () => {
    var w;
    r.value || (w = l.value) == null || w.blur();
  };
  return watch(
    () => e.modelValue,
    (w) => {
      l.value && (l.value.value = a && o ? a : w, a = null, o = true);
    }
  ), {
    input: l,
    computedId: n,
    computedAriaInvalid: b,
    onInput: T,
    onChange: _,
    onBlur: h2,
    focus: k,
    blur: C
  };
};
var mt = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const l = t.split(".");
  return mt(e[l[0]], l.splice(1).join("."));
};
var ha = (e, t = null, l, a) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const o = mt(e, a.valueField), n = mt(e, a.textField), s = mt(e, a.htmlField), r = mt(e, a.disabledField), u = e[a.optionsField] || null;
    return u !== null ? {
      label: String(mt(e, a.labelField) || n),
      options: el(u, l, a)
    } : {
      value: typeof o > "u" ? t || n : o,
      text: String(typeof n > "u" ? t : n),
      html: s,
      disabled: !!r
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: false
  };
};
var el = (e, t, l) => Array.isArray(e) ? e.map((a) => ha(a, null, t, l)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((a) => {
  const o = e[a];
  switch (typeof o) {
    case "object":
      return ha(o.text, String(o.value), t, l);
    default:
      return ha(o, String(a), t, l);
  }
})) : [];
var Ve = (e, t) => computed(() => toValue(e) || lt(t));
var Ba = "modal-open";
var Jr = rr(() => {
  const { count: e, inc: t, dec: l } = vr(), a = Za("updateHTMLAttrs", (o, n, s) => {
    const r = typeof o == "string" ? window == null ? void 0 : window.document.querySelector(o) : et(o);
    r && (n === "class" ? r.classList.toggle(Ba, s === Ba) : r.setAttribute(n, s));
  });
  return ct(() => {
    a("body", "class", "");
  }), watch(e, (o) => {
    a("body", "class", o > 0 ? Ba : "");
  }), { inc: t, dec: l };
});
var Zr = (e) => {
  const { inc: t, dec: l } = Jr();
  watch(
    e,
    (a, o) => {
      a ? t() : o && !a && l();
    },
    { immediate: true }
  );
};
var sn = (e, t) => {
  const l = readonly(toRef(e)), a = readonly(toRef(t)), o = computed(() => !a.value), n = ref(null);
  onMounted(() => {
    n.value = document.body;
  });
  const s = Wr(n, l.value && o.value);
  watch([l, o], ([r, u]) => {
    s.value = r && u;
  });
};
var Tt = (e) => computed(() => {
  const t = toValue(e);
  return t === true ? "is-valid" : t === false ? "is-invalid" : null;
});
var Qr = ["id"];
var ei = ["innerHTML"];
var ti = ["innerHTML"];
var tl = defineComponent({
  inheritAttrs: false,
  __name: "BPopover",
  props: {
    modelValue: { type: [String, Boolean], default: false },
    container: { default: void 0 },
    target: { type: [Function, String, null], default: null },
    reference: { type: [Function, String, null], default: null },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    click: { type: [String, Boolean], default: false },
    manual: { type: [String, Boolean], default: false },
    variant: { default: null },
    offset: { default: null },
    customClass: { default: "" },
    placement: { default: "top" },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: false },
    noShift: { type: [String, Boolean], default: false },
    noFade: { type: [String, Boolean], default: false },
    noAutoClose: { type: [String, Boolean], default: false },
    hide: { type: [String, Boolean], default: true },
    realtime: { type: [String, Boolean], default: false },
    inline: { type: [String, Boolean], default: false },
    tooltip: { type: [String, Boolean], default: false },
    html: { type: [String, Boolean], default: false }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = d(() => a.modelValue), n = ref(o.value), s = ref(o.value);
    watchEffect(() => {
      l("update:modelValue", n.value);
    }), watch(o, () => {
      o.value !== n.value && (o.value ? le() : de(new Event("update:modelValue")));
    });
    const r = Ve(() => a.id, "popover"), u = d(() => a.click), f = d(() => a.manual), v = d(() => a.noShift), p = d(() => a.noFlip), c = d(() => a.noFade), g = d(() => a.noAutoClose), B = d(() => a.hide), m = d(() => a.realtime), V = d(() => a.inline), b = d(() => a.tooltip), T = d(() => a.html), _ = ref(false), h2 = ref(null), k = ref(null), C = ref(null), w = ref(null), P = ref(null), F = (K) => {
      if (typeof K == "string" || K instanceof HTMLElement)
        return K;
      if (typeof K == "function")
        return K().$el ? K().$el : K();
      if (typeof K < "u")
        return K.$el;
    }, S = (K) => {
      if (K) {
        if (typeof K == "string") {
          const ce = document.getElementById(K);
          return ce || void 0;
        }
        return K;
      }
    }, I = computed(
      () => a.title ? yt(a.title, gt) : ""
    ), x = computed(
      () => a.content ? yt(a.content, gt) : ""
    ), z = computed(() => a.placement.startsWith("auto")), te = computed(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const K = typeof a.offset == "number" ? a.offset : b.value ? 0 : 10, ce = [Io(K)];
      return p.value === false && !z.value && ce.push(Fo()), z.value && ce.push(
        zs({
          alignment: a.placement.split("-")[1] || void 0
        })
      ), v.value === false && ce.push(xo()), B.value === true && ce.push(Hs({ padding: 10 })), V.value === true && ce.push(Rs()), ce.push(Us({ element: C, padding: 10 })), ce;
    }), Q = computed(
      () => z.value ? void 0 : a.placement
    ), { x: G, y: X, strategy: U, middlewareData: pe, placement: be, update: he } = Go(k, h2, {
      placement: Q,
      middleware: te,
      strategy: a.strategy,
      whileElementsMounted: (...K) => Gs(...K, { animationFrame: m.value })
    }), ye = ref({ position: "absolute" });
    watch(pe, () => {
      var K;
      if (B.value === true && ((K = pe.value.hide) != null && K.referenceHidden ? _.value = true : _.value = false), pe.value.arrow) {
        const { x: ce, y: Le } = pe.value.arrow;
        ye.value = {
          position: "absolute",
          top: Le ? `${Le}px` : "",
          left: ce ? `${ce}px` : ""
        };
      }
    });
    const q = computed(() => {
      const K = b.value ? "tooltip" : "popover";
      return [
        K,
        `b-${K}`,
        {
          [`b-${K}-${a.variant}`]: a.variant !== null,
          show: n.value && !_.value,
          ["pe-none"]: !n.value,
          fade: !c.value,
          ["d-none"]: !n.value && c.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${K}-${li(be.value)}`]: be.value !== void 0
        }
      ];
    }), { isOutside: ee } = Nl(h2), { isOutside: ne } = Nl(w), ue = (K) => {
      const ce = K ?? new Event("click");
      n.value ? de(ce) : le();
    }, N = (K, ce = {}) => new Mt(K, {
      cancelable: false,
      target: h2.value || null,
      relatedTarget: null,
      trigger: null,
      ...ce,
      componentId: r.value
    }), le = () => {
      const K = N("show", { cancelable: true });
      if (l("show", K), K.defaultPrevented) {
        l("show-prevented");
        return;
      }
      s.value = true, nextTick(() => {
        var ce;
        he(), setTimeout(
          () => {
            he(), n.value = true, nextTick(() => {
              l("shown", N("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((ce = a.delay) == null ? void 0 : ce.show) || 0
        );
      });
    }, de = (K) => {
      var E;
      const ce = N("hide", { cancelable: true });
      if (l("hide", ce), ce.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      const Le = typeof a.delay == "number" ? a.delay : ((E = a.delay) == null ? void 0 : E.hide) || 100;
      setTimeout(() => {
        var W;
        (K == null ? void 0 : K.type) === "click" || (K == null ? void 0 : K.type) === "update:modelValue" && f.value || ee.value && ne.value && !((W = h2.value) != null && W.contains(document == null ? void 0 : document.activeElement)) ? (n.value = false, nextTick(() => {
          setTimeout(
            () => {
              s.value = false;
            },
            h2.value ? _a(h2.value) : 150
          ), l("hidden", N("hidden"));
        })) : setTimeout(() => {
          de(K);
        }, Le);
      }, Le);
    };
    t({
      hideFn: de,
      show: le,
      toggle: ue
    });
    const Se = () => {
      var K;
      if (a.target) {
        const ce = S(F(a.target));
        ce ? w.value = ce : console.warn("Target element not found", a.target);
      } else
        w.value = (K = P.value) == null ? void 0 : K.nextElementSibling;
      if (a.reference) {
        const ce = S(F(a.reference));
        ce ? k.value = ce : console.warn("Reference element not found", a.reference);
      } else
        k.value = w.value;
      !w.value || f.value || qa && (u.value && w.value.addEventListener("click", ue), !u.value && w.value.addEventListener("pointerenter", le), !u.value && w.value.addEventListener("pointerleave", de), !u.value && w.value.addEventListener("focus", le), !u.value && w.value.addEventListener("blur", de));
    }, Ce = () => {
      w.value && (w.value.removeEventListener("click", ue), w.value.removeEventListener("pointerenter", le), w.value.removeEventListener("pointerleave", de), w.value.removeEventListener("focus", le), w.value.removeEventListener("blur", de));
    };
    return Jo(
      h2,
      () => {
        n.value && u.value && !g.value && !f.value && de(new Event("clickOutside"));
      },
      { ignore: [w] }
    ), watch([() => a.click, () => a.target, () => a.reference], () => {
      Ce(), Se();
    }), onMounted(Se), onBeforeUnmount(Ce), (K, ce) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("span", {
        ref_key: "placeholder",
        ref: P
      }, null, 512),
      renderSlot(K.$slots, "target", normalizeProps(guardReactiveProps({ show: le, hide: de, toggle: ue, showState: n.value }))),
      createVNode(Qa, {
        tag: "Teleport",
        to: K.container,
        skip: !K.container
      }, {
        default: withCtx(() => [
          s.value ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            id: K.id
          }, K.$attrs, {
            ref_key: "element",
            ref: h2,
            class: q.value,
            role: "tooltip",
            tabindex: "-1",
            style: {
              position: unref(U),
              top: `${unref(X)}px`,
              left: `${unref(G)}px`,
              width: "max-content"
            }
          }), [
            createBaseVNode("div", {
              ref_key: "arrow",
              ref: C,
              class: normalizeClass(`${unref(b) ? "tooltip" : "popover"}-arrow`),
              style: normalizeStyle(ye.value),
              "data-popper-arrow": ""
            }, null, 6),
            K.title || K.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              unref(T) ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(b) ? "tooltip-inner" : "popover-header"),
                innerHTML: I.value
              }, null, 10, ei)) : (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(b) ? "tooltip-inner" : "popover-header")
              }, [
                renderSlot(K.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(K.title), 1)
                ])
              ], 2))
            ], 64)) : createCommentVNode("", true),
            unref(b) && !K.$slots.title && !K.title || !unref(b) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              unref(T) ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(b) ? "tooltip-inner" : "popover-body"),
                innerHTML: x.value
              }, null, 10, ti)) : (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(b) ? "tooltip-inner" : "popover-body")
              }, [
                renderSlot(K.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(K.content), 1)
                ])
              ], 2))
            ], 64)) : createCommentVNode("", true)
          ], 16, Qr)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["to", "skip"])
    ], 64));
  }
});
var ai = ({
  top: e,
  end: t,
  start: l,
  alignCenter: a,
  alignEnd: o
}) => {
  const n = e ? "top" : l ? "left" : t ? "right" : "bottom", s = o ? "end" : a ? null : "start";
  return `${n}${s ? `-${s}` : ""}`;
};
var li = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
};
var Ht = (e) => typeof e != "object" || e.active !== false;
var sa = (e, t) => {
  if (!Ht(e))
    return {};
  const a = typeof e > "u" || typeof e == "object" && !e.title && !e.content, o = t.getAttribute("title") || t.getAttribute("data-original-title");
  return a ? o ? (t.removeAttribute("title"), t.setAttribute("data-original-title", o), {
    content: yt(o, gt)
  }) : (console.warn(
    "Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \"my title\"}'` nor `v-b-tooltip=\"'my title'\"` to define a title"
  ), {}) : typeof e == "string" ? {
    content: yt(e, gt)
  } : {
    title: e != null && e.title ? yt(e == null ? void 0 : e.title, gt) : void 0,
    content: e != null && e.content ? yt(e == null ? void 0 : e.content, gt) : void 0
  };
};
var ra = (e, t) => ({
  target: () => t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: true,
  ...typeof e.value == "object" ? e.value : {},
  title: null,
  content: null
});
var rn = (e, t) => {
  var a;
  const l = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(l) : t.modifiers.child ? e.appendChild(l) : (a = e.parentNode) == null || a.insertBefore(l, e.nextSibling), e.$__app = createApp({ render: () => {
    var o;
    return h(tl, { ...(o = e.$__state) == null ? void 0 : o.value });
  } }), e.$__app.mount(l), e.$__element = l;
};
var un = (e) => {
  var l;
  const t = e.$__element;
  (l = e.$__app) == null || l.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {
    t == null || t.remove();
  }, 0), delete e.$__element;
};
var zl = (e, t) => {
  const { all: l, ...a } = e, o = {};
  l && t.forEach((s) => {
    o[s] = l;
  });
  const n = { ...o, ...a };
  return Object.entries(n).filter(([s, r]) => !!r && t.includes(s)).map(([s]) => s);
};
var oi = ["id"];
var ni = defineComponent({
  __name: "BAccordion",
  props: {
    flush: { type: [String, Boolean], default: false },
    free: { type: [String, Boolean], default: false },
    id: { default: void 0 },
    modelValue: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const l = e, a = ke(l, "modelValue", t, { passive: true }), o = Ve(() => l.id, "accordion"), n = d(() => l.flush), s = d(() => l.free), r = computed(() => ({
      "accordion-flush": n.value
    }));
    return provide(To, {
      openItem: readonly(a),
      free: s,
      setOpenItem: (u) => {
        a.value = u;
      }
    }), (u, f) => (openBlock(), createElementBlock("div", {
      id: unref(o),
      class: normalizeClass(["accordion", r.value])
    }, [
      renderSlot(u.$slots, "default")
    ], 10, oi));
  }
});
var dn = defineComponent({
  inheritAttrs: false,
  __name: "BCollapse",
  props: {
    id: { default: void 0 },
    modelValue: { type: [String, Boolean], default: false },
    tag: { default: "div" },
    toggle: { type: [String, Boolean], default: false },
    horizontal: { type: [String, Boolean], default: false },
    visible: { type: [String, Boolean], default: false },
    isNav: { type: [String, Boolean], default: false }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = (k, C = {}) => new Mt(k, {
      cancelable: false,
      target: c.value || null,
      relatedTarget: null,
      trigger: null,
      ...C,
      componentId: p.value
    }), n = ke(a, "modelValue", l, { passive: true }), s = d(n), r = d(() => a.toggle), u = d(() => a.horizontal), f = d(() => a.isNav), v = d(() => a.visible), p = Ve(() => a.id, "collapse"), c = ref(null), g = ref(false), B = ref(s.value), m = computed(() => ({
      show: B.value,
      "navbar-collapse": f.value,
      collapsing: g.value,
      closing: B.value && !s.value,
      "collapse-horizontal": u.value
    })), V = () => {
      n.value = false;
    }, b = () => {
      n.value = true;
    }, T = () => {
      n.value = !s.value;
    }, _ = () => {
      B.value = true, g.value = true;
      const k = o("show", { cancelable: true });
      if (l("show", k), k.defaultPrevented) {
        l("show-prevented");
        return;
      }
      nextTick(() => {
        c.value !== null && (u.value ? c.value.style.width = `${c.value.scrollWidth}px` : c.value.style.height = `${c.value.scrollHeight}px`, setTimeout(() => {
          g.value = false, l("shown", o("shown")), c.value !== null && (c.value.style.height = "", c.value.style.width = "");
        }, _a(c.value)));
      });
    }, h2 = () => {
      const k = o("hide", { cancelable: true });
      if (l("hide", k), k.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      c.value !== null && (u.value ? c.value.style.width = `${c.value.scrollWidth}px` : c.value.style.height = `${c.value.scrollHeight}px`, c.value.offsetHeight, g.value = true, nextTick(() => {
        c.value !== null && (c.value.style.height = "", c.value.style.width = "", setTimeout(() => {
          B.value = false, g.value = false, l("hidden", o("hidden"));
        }, _a(c.value)));
      }));
    };
    return watch([n, B], () => {
      if (s.value === true) {
        if (B.value)
          return;
        _();
        return;
      }
      h2();
    }), onMounted(() => {
      c.value !== null && !s.value && r.value && nextTick(() => {
        n.value = true;
      });
    }), v.value && (n.value = true, B.value = true), watch(v, (k) => {
      k ? b() : V();
    }), Te(c, "bv-toggle", () => {
      n.value = !s.value;
    }), t({
      close: V,
      open: b,
      toggle: T,
      visible: readonly(B),
      isNav: f
    }), provide(Wa, {
      id: p,
      close: V,
      open: b,
      toggle: T,
      visible: readonly(B),
      isNav: f
    }), (k, C) => (openBlock(), createElementBlock(Fragment, null, [
      renderSlot(k.$slots, "header", normalizeProps(guardReactiveProps({ visible: unref(s), toggle: T, open: b, close: V, id: unref(p) }))),
      (openBlock(), createBlock(resolveDynamicComponent(k.tag), mergeProps({
        id: unref(p),
        ref_key: "element",
        ref: c,
        class: ["collapse", m.value],
        "is-nav": unref(f)
      }, k.$attrs), {
        default: withCtx(() => [
          renderSlot(k.$slots, "default", normalizeProps(guardReactiveProps({ visible: unref(s), toggle: k.toggle, open: b, close: V })))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      renderSlot(k.$slots, "footer", normalizeProps(guardReactiveProps({ visible: unref(s), toggle: T, open: b, close: V, id: unref(p) })))
    ], 64));
  }
});
var si = { class: "accordion-item" };
var ri = ["aria-expanded", "aria-controls", "onClick"];
var ii = { class: "accordion-body" };
var ui = defineComponent({
  inheritAttrs: false,
  __name: "BAccordionItem",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    modelValue: { type: [String, Boolean], default: false },
    headerTag: { default: "h2" },
    tag: { default: void 0 },
    toggle: { type: [String, Boolean], default: void 0 },
    horizontal: { type: [String, Boolean], default: void 0 },
    visible: { type: [String, Boolean], default: false },
    isNav: { type: [String, Boolean], default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const l = e, a = {
      show: (r) => t("show", r),
      shown: (r) => t("shown", r),
      hide: (r) => t("hide", r),
      hidden: (r) => t("hidden", r),
      "hide-prevented": () => t("hide-prevented"),
      "show-prevented": () => t("show-prevented")
    }, o = ke(l, "modelValue", t, { passive: true }), n = inject(To, null), s = Ve(() => l.id, "accordion_item");
    return onMounted(() => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value)), !o.value && (n == null ? void 0 : n.openItem.value) === s.value && (o.value = true);
    }), watch(
      () => n == null ? void 0 : n.openItem.value,
      () => o.value = (n == null ? void 0 : n.openItem.value) === s.value && !(n != null && n.free.value)
    ), watch(o, () => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value));
    }), (r, u) => (openBlock(), createElementBlock("div", si, [
      createVNode(dn, mergeProps({
        id: unref(s),
        modelValue: unref(o),
        "onUpdate:modelValue": u[0] || (u[0] = (f) => isRef(o) ? o.value = f : null),
        class: "accordion-collapse"
      }, r.$attrs, {
        "aria-labelledby": `${unref(s)}-heading`,
        tag: r.tag,
        toggle: r.toggle,
        horizontal: r.horizontal,
        visible: r.visible,
        "is-nav": r.isNav
      }, toHandlers(a)), {
        header: withCtx(({ visible: f, toggle: v }) => [
          (openBlock(), createBlock(resolveDynamicComponent(r.headerTag), {
            id: `${unref(s)}-heading`,
            class: "accordion-header"
          }, {
            default: withCtx(() => [
              createBaseVNode("button", {
                class: normalizeClass(["accordion-button", { collapsed: !f }]),
                type: "button",
                "aria-expanded": f ? "true" : "false",
                "aria-controls": unref(s),
                onClick: v
              }, [
                renderSlot(r.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(r.title), 1)
                ])
              ], 10, ri)
            ]),
            _: 2
          }, 1032, ["id"]))
        ]),
        default: withCtx(() => [
          createBaseVNode("div", ii, [
            renderSlot(r.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, ["id", "modelValue", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ]));
  }
});
var Vt = defineComponent({
  __name: "BTransition",
  props: {
    appear: { type: [String, Boolean], default: false },
    mode: { default: void 0 },
    noFade: { type: [String, Boolean], default: false },
    transProps: { default: void 0 }
  },
  setup(e) {
    const t = e, l = d(() => t.appear), a = d(() => t.noFade), o = computed(() => {
      const r = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, u = {
        ...r,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return a.value ? r : u;
    }), n = computed(() => ({ mode: t.mode, css: true, ...o.value })), s = computed(
      () => t.transProps !== void 0 ? {
        // Order matters here since the props.transProps would get overwritten if it came first
        // But the goal of props.transProps is to overwrite base properties
        ...n.value,
        ...t.transProps
      } : l.value ? {
        ...n.value,
        appear: true,
        appearActiveClass: o.value.enterActiveClass,
        appearToClass: o.value.enterToClass
      } : n.value
    );
    return (r, u) => (openBlock(), createBlock(Transition, normalizeProps(guardReactiveProps(s.value)), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var di = ["type", "disabled", "aria-label"];
var Ot = defineComponent({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: [String, Boolean], default: false },
    white: { type: [String, Boolean], default: false },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.disabled), o = d(() => l.white), n = computed(() => ({
      "btn-close-white": o.value
    }));
    return (s, r) => (openBlock(), createElementBlock("button", {
      type: s.type,
      class: normalizeClass(["btn-close", n.value]),
      disabled: unref(a),
      "aria-label": s.ariaLabel,
      onClick: r[0] || (r[0] = (u) => t("click", u))
    }, null, 10, di));
  }
});
var ci = {
  key: 0,
  class: "visually-hidden"
};
var ma = defineComponent({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: [String, Boolean], default: false },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = useSlots(), a = d(() => t.small), o = computed(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && a.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && a.value,
      [`text-${t.variant}`]: t.variant !== null
    })), n = computed(() => !Fe(l.label));
    return (s, r) => (openBlock(), createBlock(resolveDynamicComponent(s.tag), {
      class: normalizeClass(o.value),
      role: s.label || n.value ? s.role : null,
      "aria-hidden": s.label || n.value ? null : true
    }, {
      default: withCtx(() => [
        s.label || n.value ? (openBlock(), createElementBlock("span", ci, [
          renderSlot(s.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(s.label), 1)
          ])
        ])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
});
var fi = {
  active: { type: [Boolean, String, void 0], default: void 0 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: false },
  disabled: { type: [Boolean, String], default: false },
  event: { type: [String, Array], default: "click" },
  href: { type: String },
  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},
  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: false },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null },
  variant: { type: String, default: null }
};
var Qe = defineComponent({
  __name: "BLink",
  props: {
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    event: { default: "click" },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: false },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: null },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: false }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = useAttrs(), o = d(() => l.active), n = d(() => l.icon);
    d(() => l.append);
    const s = d(() => l.disabled);
    d(() => l.replace);
    const r = inject(Wa, null), u = inject(Ua, null), f = () => {
      var b;
      u !== null && ((b = r == null ? void 0 : r.close) == null || b.call(r));
    }, v = getCurrentInstance(), p = computed(() => {
      const b = l.routerComponentName.split("-").map((_) => _.charAt(0).toUpperCase() + _.slice(1)).join("");
      return !((v == null ? void 0 : v.appContext.app.component(b)) !== void 0) || s.value || !l.to ? "a" : l.routerComponentName;
    }), c = computed(() => {
      const b = "#";
      if (l.href)
        return l.href;
      if (typeof l.to == "string")
        return l.to || b;
      const T = l.to;
      if (Object.prototype.toString.call(T) === "[object Object]" && (T.path || T.query || T.hash)) {
        const _ = T.path || "", h2 = T.query ? `?${Object.keys(T.query).map((C) => `${C}=${T.query[C]}`).join("=")}` : "", k = !T.hash || T.hash.charAt(0) === "#" ? T.hash || "" : `#${T.hash}`;
        return `${_}${h2}${k}` || b;
      }
      return b;
    }), g = computed(() => ({
      [`link-${l.variant}`]: l.variant !== null,
      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,
      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,
      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,
      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,
      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,
      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,
      "icon-link": n.value === true
    })), B = computed(() => ({
      class: g.value,
      to: l.to,
      href: c.value,
      target: l.target,
      rel: l.target === "_blank" && l.rel === void 0 ? "noopener" : l.rel || void 0,
      tabindex: s.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": s.value ? true : null
    })), m = computed(() => ({
      active: o.value,
      disabled: s.value
    })), V = (b) => {
      var T;
      if (s.value) {
        b.preventDefault(), b.stopImmediatePropagation();
        return;
      }
      (T = r == null ? void 0 : r.close) == null || T.call(r), t("click", b);
    };
    return (b, T) => p.value === "router-link" ? (openBlock(), createBlock(resolveDynamicComponent(p.value), mergeProps({ key: 0 }, B.value, { custom: "" }), {
      default: withCtx(({ href: _, navigate: h2, isActive: k }) => [
        (openBlock(), createBlock(resolveDynamicComponent(b.routerTag), mergeProps({
          href: _,
          class: [(unref(o) ?? k) && b.activeClass]
        }, b.$attrs, {
          onClick: (C) => {
            h2(C), f(), V(C);
          }
        }), {
          default: withCtx(() => [
            renderSlot(b.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (openBlock(), createBlock(resolveDynamicComponent(p.value), mergeProps({
      key: 1,
      class: m.value
    }, B.value, { onClick: V }), {
      default: withCtx(() => [
        renderSlot(b.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var kt = defineComponent({
  __name: "BButton",
  props: {
    pill: { type: [String, Boolean], default: false },
    pressed: { type: [String, Boolean], default: void 0 },
    size: { default: "md" },
    squared: { type: [String, Boolean], default: false },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    loading: { type: [String, Boolean], default: false },
    loadingMode: { default: "inline" },
    block: { type: [String, Boolean], default: false },
    active: { type: [String, Boolean], default: false },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    event: { default: "click" },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: false },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: "_self" },
    to: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: false }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const l = e, a = ke(l, "pressed", t), o = d(() => l.active), n = d(() => l.block), s = d(() => l.disabled), r = d(() => l.pill), u = d(() => l.pressed), f = d(() => l.squared), v = d(() => l.loading), p = computed(() => typeof u.value == "boolean"), c = computed(
      () => l.tag === "button" && l.href === void 0 && l.to === void 0
    ), g = computed(() => St(l)), B = computed(() => l.to !== void 0), m = computed(() => l.href !== void 0 ? false : !c.value), V = computed(() => [
      [`btn-${l.size}`],
      {
        [`btn-${l.variant}`]: l.variant !== null,
        "btn-block": n.value,
        active: o.value || u.value,
        "rounded-pill": r.value,
        "rounded-0": f.value,
        disabled: s.value
      }
    ]), b = computed(() => ({
      "aria-disabled": m.value ? s.value : null,
      "aria-pressed": p.value ? u.value : null,
      autocomplete: p.value ? "off" : null,
      disabled: c.value ? s.value : null,
      href: l.href,
      rel: g.value ? l.rel : null,
      role: m.value || g.value ? "button" : null,
      target: g.value ? l.target : null,
      type: c.value ? l.type : null,
      to: c.value ? null : l.to,
      append: g.value ? l.append : null,
      activeClass: B.value ? l.activeClass : null,
      event: B.value ? l.event : null,
      replace: B.value ? l.replace : null,
      routerComponentName: B.value ? l.routerComponentName : null,
      routerTag: B.value ? l.routerTag : null
    })), T = computed(
      () => B.value ? Qe : l.href ? "a" : l.tag
    ), _ = (h2) => {
      if (s.value) {
        h2.preventDefault(), h2.stopPropagation();
        return;
      }
      t("click", h2), p.value && (a.value = !u.value);
    };
    return (h2, k) => (openBlock(), createBlock(resolveDynamicComponent(T.value), mergeProps({
      class: ["btn", V.value]
    }, b.value, { onClick: _ }), {
      default: withCtx(() => [
        unref(v) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["btn-loading", { "mode-fill": h2.loadingMode === "fill", "mode-inline": h2.loadingMode === "inline" }])
        }, [
          renderSlot(h2.$slots, "loading", {}, () => [
            createVNode(ma, {
              class: "btn-spinner",
              small: h2.size !== "lg"
            }, null, 8, ["small"])
          ])
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["btn-content", { "btn-loading-fill": unref(v) && h2.loadingMode === "fill" }])
        }, [
          renderSlot(h2.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var vi = ["onMouseenter"];
var pi = defineComponent({
  __name: "BAlert",
  props: {
    noHoverPause: { type: [String, Boolean], default: false },
    dismissLabel: { default: "Close" },
    dismissible: { type: [String, Boolean], default: false },
    fade: { type: [String, Boolean], default: false },
    closeVariant: { default: "secondary" },
    modelValue: { type: [Boolean, Number], default: false },
    variant: { default: "info" },
    closeContent: { default: void 0 },
    immediate: { type: [String, Boolean], default: true },
    interval: { default: 1e3 },
    showOnPause: { type: [String, Boolean], default: true }
  },
  emits: ["closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = useSlots(), n = ke(a, "modelValue", l), s = d(() => a.dismissible), r = d(() => a.fade), u = d(() => a.immediate), f = d(() => a.showOnPause), v = d(() => a.noHoverPause), p = computed(() => !Fe(o.close)), c = computed(
      () => typeof n.value == "boolean" ? 0 : n.value
    ), g = computed(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": s.value
    })), {
      isActive: B,
      pause: m,
      restart: V,
      resume: b,
      stop: T,
      isPaused: _,
      value: h2
    } = Yr(c, () => a.interval, {
      immediate: typeof n.value == "number" && u.value
    }), k = computed(
      () => typeof n.value == "boolean" ? n.value : B.value || f.value && _.value
    ), C = computed(() => ({
      variant: a.closeVariant,
      type: "button"
    }));
    watchEffect(() => l("close-countdown", h2.value));
    const w = () => {
      typeof n.value == "boolean" ? n.value = false : (n.value = 0, T()), l("closed");
    }, P = () => {
      v.value || m();
    };
    return onBeforeUnmount(T), t({ pause: m, resume: b, restart: V, stop: T }), (F, S) => (openBlock(), createBlock(Vt, {
      "no-fade": !unref(r),
      "trans-props": { enterToClass: "show" }
    }, {
      default: withCtx(() => [
        k.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["alert", g.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true",
          onMouseenter: withModifiers(P, ["stop"]),
          onMouseleave: S[0] || (S[0] = withModifiers(
            //@ts-ignore
            (...I) => unref(b) && unref(b)(...I),
            ["stop"]
          ))
        }, [
          renderSlot(F.$slots, "default"),
          unref(s) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            p.value || F.closeContent ? (openBlock(), createBlock(kt, mergeProps({ key: 0 }, C.value, { onClick: w }), {
              default: withCtx(() => [
                renderSlot(F.$slots, "close", {}, () => [
                  createTextVNode(toDisplayString(F.closeContent), 1)
                ])
              ]),
              _: 3
            }, 16)) : (openBlock(), createBlock(Ot, mergeProps({
              key: 1,
              "aria-label": F.dismissLabel
            }, C.value, { onClick: w }), null, 16, ["aria-label"]))
          ], 64)) : createCommentVNode("", true)
        ], 42, vi)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
});
var mi = {
  key: 0,
  class: "b-avatar-custom"
};
var gi = {
  key: 1,
  class: "b-avatar-img"
};
var yi = ["src", "alt"];
var Oa = (e) => {
  const t = typeof e == "string" && po(e) ? Et(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
};
var bi = defineComponent({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: { default: void 0 },
    badge: { type: [Boolean, String], default: false },
    badgeLeft: { type: [String, Boolean], default: false },
    badgeOffset: { default: void 0 },
    badgeTop: { type: [String, Boolean], default: false },
    badgeVariant: { default: "primary" },
    button: { type: [String, Boolean], default: false },
    buttonType: { default: "button" },
    disabled: { type: [String, Boolean], default: false },
    icon: { type: [String, Boolean], default: void 0 },
    rounded: { type: [Boolean, String], default: "circle" },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: false },
    src: { default: void 0 },
    text: { default: void 0 },
    textVariant: { default: null },
    variant: { default: "secondary" },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: false },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: false },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const l = e, a = useSlots(), o = inject(Co, null), n = ["sm", null, "lg"], s = 0.4, r = s * 0.7, u = d(() => l.badgeLeft), f = d(() => l.badgeTop), v = d(() => l.button), p = d(() => l.disabled), c = d(() => l.square), g = computed(() => !Fe(a.default)), B = computed(() => !Fe(a.badge)), m = computed(() => !!l.badge || l.badge === "" || B.value), V = computed(() => St(l)), b = computed(
      () => (o == null ? void 0 : o.size.value) ?? Oa(l.size)
    ), T = computed(
      () => (o == null ? void 0 : o.variant.value) ?? l.variant
    ), _ = computed(() => (o == null ? void 0 : o.rounded.value) ?? l.rounded), h2 = computed(() => ({
      type: v.value && !V.value ? l.buttonType : void 0,
      "aria-label": l.ariaLabel || null,
      disabled: p.value || null,
      // Link props
      ...V.value ? Dt(l, {
        active: true,
        activeClass: true,
        append: true,
        href: true,
        rel: true,
        replace: true,
        routerComponentName: true,
        target: true,
        to: true,
        variant: true,
        opacity: true,
        opacityHover: true,
        underlineVariant: true,
        underlineOffset: true,
        underlineOffsetHover: true,
        underlineOpacity: true,
        underlineOpacityHover: true
      }) : {}
    })), k = computed(() => ({
      [`bg-${l.badgeVariant}`]: l.badgeVariant !== null
    })), C = computed(() => l.badge === true ? "" : l.badge), w = computed(() => ({
      [`text-${l.badgeVariant !== null && Q(l.badgeVariant)}`]: l.badgeVariant !== null
    })), P = computed(() => ({
      [`b-avatar-${l.size}`]: !!l.size && n.indexOf(Oa(l.size)) !== -1,
      [`bg-${T.value}`]: T.value !== null,
      badge: !v.value && T.value !== null && g.value,
      rounded: _.value === "" || _.value === true,
      ["rounded-circle"]: !c.value && _.value === "circle",
      ["rounded-0"]: c.value || _.value === "0",
      ["rounded-1"]: !c.value && _.value === "sm",
      ["rounded-3"]: !c.value && _.value === "lg",
      ["rounded-top"]: !c.value && _.value === "top",
      ["rounded-bottom"]: !c.value && _.value === "bottom",
      ["rounded-start"]: !c.value && _.value === "left",
      ["rounded-end"]: !c.value && _.value === "right",
      btn: v.value,
      [`btn-${T.value}`]: v.value ? T.value !== null : false
    })), F = computed(() => ({
      [`text-${l.textVariant || T.value !== null && Q(T.value)}`]: l.textVariant || T.value !== null
    })), S = computed(() => {
      const U = l.badgeOffset || "0px";
      return {
        fontSize: (n.indexOf(b.value || null) === -1 ? `calc(${b.value} * ${r})` : "") || "",
        top: f.value ? U : "",
        bottom: f.value ? "" : U,
        left: u.value ? U : "",
        right: u.value ? "" : U
      };
    }), I = computed(() => {
      const U = n.indexOf(b.value || null) === -1 ? `calc(${b.value} * ${s})` : null;
      return U ? { fontSize: U } : {};
    }), x = computed(() => {
      var be;
      const U = ((be = o == null ? void 0 : o.overlapScale) == null ? void 0 : be.value) || 0, pe = b.value && U ? `calc(${b.value} * -${U})` : null;
      return pe ? { marginLeft: pe, marginRight: pe } : {};
    }), z = computed(
      () => V.value ? Qe : v.value ? "button" : "span"
    ), te = computed(() => ({
      ...x.value,
      width: b.value ?? void 0,
      height: b.value ?? void 0
    })), Q = (U) => U === "light" || U === "warning" ? "dark" : "light", G = (U) => {
      !p.value && (V.value || v.value) && t("click", U);
    }, X = (U) => t("img-error", U);
    return (U, pe) => (openBlock(), createBlock(resolveDynamicComponent(z.value), mergeProps({
      class: ["b-avatar", P.value],
      style: te.value
    }, h2.value, { onClick: G }), {
      default: withCtx(() => [
        g.value ? (openBlock(), createElementBlock("span", mi, [
          renderSlot(U.$slots, "default")
        ])) : U.src ? (openBlock(), createElementBlock("span", gi, [
          createBaseVNode("img", {
            src: U.src,
            alt: U.alt,
            onError: X
          }, null, 40, yi)
        ])) : U.text ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass(["b-avatar-text", F.value]),
          style: normalizeStyle(I.value)
        }, toDisplayString(U.text), 7)) : createCommentVNode("", true),
        m.value ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: normalizeClass(["b-avatar-badge", k.value]),
          style: normalizeStyle(S.value)
        }, [
          B.value ? renderSlot(U.$slots, "badge", { key: 0 }) : (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass(w.value)
          }, toDisplayString(C.value), 3))
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
});
var hi = defineComponent({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: false },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: false },
    tag: { default: "div" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = d(() => t.square), a = computed(() => Oa(t.size)), o = computed(
      () => Math.min(Math.max(s(t.overlap), 0), 1) / 2
    ), n = computed(() => {
      const r = a.value ? `calc(${a.value} * ${o.value})` : null;
      return r ? { paddingLeft: r, paddingRight: r } : {};
    }), s = (r) => typeof r == "string" && po(r) ? Et(r, 0) : r || 0;
    return provide(Co, {
      overlapScale: o,
      size: readonly(toRef(t, "size")),
      square: l,
      rounded: readonly(toRef(t, "rounded")),
      variant: readonly(toRef(t, "variant"))
    }), (r, u) => (openBlock(), createBlock(resolveDynamicComponent(r.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: withCtx(() => [
        createBaseVNode("div", {
          class: "b-avatar-group-inner",
          style: normalizeStyle(n.value)
        }, [
          renderSlot(r.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
});
var Bi = defineComponent({
  __name: "BBadge",
  props: {
    pill: { type: [String, Boolean], default: false },
    tag: { default: "span" },
    textIndicator: { type: [String, Boolean], default: false },
    dotIndicator: { type: [String, Boolean], default: false },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: false },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: "secondary" },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.pill), a = d(() => t.textIndicator), o = d(() => t.dotIndicator), n = d(() => t.active), s = d(() => t.disabled), r = computed(() => St(t)), u = computed(() => r.value ? Qe : t.tag), f = computed(() => ({
      [`bg-${t.variant}`]: t.variant !== null,
      active: n.value,
      disabled: s.value,
      "text-dark": t.variant !== null && ["warning", "info", "light"].includes(t.variant),
      "rounded-pill": l.value,
      "position-absolute top-0 start-100 translate-middle": a.value || o.value,
      "p-2 border border-light rounded-circle": o.value,
      "text-decoration-none": r.value
    })), v = computed(
      () => r.value ? Dt(t, {
        active: true,
        activeClass: true,
        append: true,
        disabled: true,
        href: true,
        rel: true,
        replace: true,
        routerComponentName: true,
        target: true,
        to: true,
        variant: true,
        opacity: true,
        opacityHover: true,
        underlineVariant: true,
        underlineOffset: true,
        underlineOffsetHover: true,
        underlineOpacity: true,
        underlineOpacityHover: true,
        icon: true
      }) : {}
    );
    return (p, c) => (openBlock(), createBlock(resolveDynamicComponent(u.value), mergeProps({
      class: ["badge", f.value]
    }, v.value), {
      default: withCtx(() => [
        renderSlot(p.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var cn = defineComponent({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: [String, Boolean], default: false },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: false },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: false }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = computed(() => ({
      active: a.value
    })), s = computed(() => a.value ? "span" : Qe), r = computed(() => a.value ? l.ariaCurrent : void 0), u = computed(
      () => s.value !== "span" ? Dt(l, {
        active: true,
        activeClass: true,
        append: true,
        disabled: true,
        href: true,
        rel: true,
        replace: true,
        routerComponentName: true,
        target: true,
        to: true,
        variant: true,
        opacity: true,
        opacityHover: true,
        underlineVariant: true,
        underlineOffset: true,
        underlineOffsetHover: true,
        underlineOpacity: true,
        underlineOpacityHover: true,
        icon: true
      }) : {}
    ), f = (v) => {
      if (o.value || a.value) {
        v.preventDefault(), v.stopImmediatePropagation();
        return;
      }
      o.value || t("click", v);
    };
    return (v, p) => (openBlock(), createElementBlock("li", {
      class: normalizeClass(["breadcrumb-item", n.value])
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(s.value), mergeProps({ "aria-current": r.value }, u.value, { onClick: f }), {
        default: withCtx(() => [
          renderSlot(v.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(v.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
});
var Si = { "aria-label": "breadcrumb" };
var _i = { class: "breadcrumb" };
var wi = defineComponent({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, l = Qo(), a = computed(() => {
      const o = t.items || (l == null ? void 0 : l.items) || [];
      let n = false;
      return o.map((r, u) => (typeof r == "string" && (r = { text: r }, u < o.length - 1 && (r.href = "#")), r.active && (n = true), !r.active && !n && (r.active = u + 1 === o.length), r));
    });
    return (o, n) => (openBlock(), createElementBlock("nav", Si, [
      createBaseVNode("ol", _i, [
        renderSlot(o.$slots, "prepend"),
        (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (s, r) => (openBlock(), createBlock(cn, mergeProps({ key: r }, s), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(s.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        renderSlot(o.$slots, "default"),
        renderSlot(o.$slots, "append")
      ])
    ]));
  }
});
var $i = defineComponent({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.vertical), a = computed(() => ({
      "btn-group": !l.value,
      [`btn-group-${t.size}`]: t.size !== "md",
      "btn-group-vertical": l.value
    }));
    return (o, n) => (openBlock(), createBlock(resolveDynamicComponent(o.tag), {
      class: normalizeClass(a.value),
      role: "group",
      "aria-label": o.ariaLabel
    }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
});
var ki = ["role", "aria-label"];
var Ci = defineComponent({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: [String, Boolean], default: false },
    role: { default: "toolbar" }
  },
  setup(e) {
    const t = e, l = d(() => t.justify), a = computed(() => ({
      "justify-content-between": l.value
    }));
    return (o, n) => (openBlock(), createElementBlock("div", {
      class: normalizeClass([a.value, "btn-toolbar"]),
      role: o.role,
      "aria-label": o.ariaLabel
    }, [
      renderSlot(o.$slots, "default")
    ], 10, ki));
  }
});
var Ti = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>';
var al = defineComponent({
  __name: "BImg",
  props: {
    alt: { default: void 0 },
    blank: { type: [String, Boolean], default: false },
    blankColor: { default: "transparent" },
    block: { type: [String, Boolean], default: false },
    center: { type: [String, Boolean], default: false },
    fluid: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: false },
    fluidGrow: { type: [String, Boolean], default: false },
    height: { default: void 0 },
    start: { type: [String, Boolean], default: false },
    end: { type: [String, Boolean], default: false },
    rounded: { type: [Boolean, String], default: false },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: [String, Boolean], default: false },
    width: { default: void 0 }
  },
  setup(e) {
    const t = e, l = d(() => t.lazy), a = d(() => t.blank), o = d(() => t.block), n = d(() => t.center), s = d(() => t.fluid), r = d(() => t.fluidGrow), u = d(() => t.start), f = d(() => t.end), v = d(() => t.thumbnail), p = computed(
      () => typeof t.srcset == "string" ? t.srcset.split(",").filter((_) => _).join(",") : Array.isArray(t.srcset) ? t.srcset.filter((_) => _).join(",") : void 0
    ), c = computed(
      () => typeof t.sizes == "string" ? t.sizes.split(",").filter((_) => _).join(",") : Array.isArray(t.sizes) ? t.sizes.filter((_) => _).join(",") : void 0
    ), g = computed(() => {
      const _ = (C) => C === void 0 ? void 0 : typeof C == "number" ? C : Number.parseInt(C, 10) || void 0, h2 = _(t.width), k = _(t.height);
      if (a.value) {
        if (h2 !== void 0 && k === void 0)
          return { height: h2, width: h2 };
        if (h2 === void 0 && k !== void 0)
          return { height: k, width: k };
        if (h2 === void 0 && k === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: h2,
        height: k
      };
    }), B = computed(
      () => T(g.value.width, g.value.height, t.blankColor)
    ), m = computed(() => ({
      src: a.value ? B.value : t.src,
      alt: t.alt,
      width: g.value.width || void 0,
      height: g.value.height || void 0,
      srcset: a.value ? void 0 : p.value,
      sizes: a.value ? void 0 : c.value,
      loading: l.value ? "lazy" : "eager"
    })), V = computed(
      () => u.value ? "float-start" : f.value ? "float-end" : n.value ? "mx-auto" : void 0
    ), b = computed(() => ({
      "img-thumbnail": v.value,
      "img-fluid": s.value || r.value,
      "w-100": r.value,
      rounded: t.rounded === "" || t.rounded === true,
      [`rounded-${t.rounded}`]: typeof t.rounded == "string" && t.rounded !== "",
      [`${V.value}`]: V.value !== void 0,
      "d-block": o.value || n.value
    })), T = (_, h2, k) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      Ti.replace("%{w}", String(_)).replace("%{h}", String(h2)).replace("%{f}", k)
    )}`;
    return (_, h2) => (openBlock(), createElementBlock("img", mergeProps({ class: b.value }, m.value), null, 16));
  }
});
var ia = defineComponent({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    blank: { type: [String, Boolean], default: false },
    blankColor: { default: void 0 },
    bottom: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: false },
    height: { default: void 0 },
    start: { type: [String, Boolean], default: false },
    end: { type: [String, Boolean], default: false },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    top: { type: [String, Boolean], default: false },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.bottom), o = d(() => l.end), n = d(() => l.start), s = d(() => l.top), r = computed(
      () => s.value ? "card-img-top" : o.value ? "card-img-right" : a.value ? "card-img-bottom" : n.value ? "card-img-left" : "card-img"
    ), u = computed(() => ({
      alt: l.alt,
      height: l.height,
      src: l.src,
      lazy: l.lazy,
      width: l.width,
      blank: l.blank,
      blankColor: l.blankColor,
      sizes: l.sizes,
      srcset: l.srcset
    }));
    return (f, v) => (openBlock(), createBlock(al, mergeProps({ class: r.value }, u.value, {
      onLoad: v[0] || (v[0] = (p) => t("load", p))
    }), null, 16, ["class"]));
  }
});
var Vi = ["innerHTML"];
var fn = defineComponent({
  __name: "BCardHeadFoot",
  props: {
    text: { default: void 0 },
    bgVariant: { default: null },
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      [`bg-${t.bgVariant}`]: t.bgVariant !== null,
      [`border-${t.borderVariant}`]: t.borderVariant !== null
    }));
    return (a, o) => (openBlock(), createBlock(resolveDynamicComponent(a.tag), {
      class: normalizeClass(l.value)
    }, {
      default: withCtx(() => [
        a.html ? (openBlock(), createElementBlock("div", {
          key: 0,
          innerHTML: a.html
        }, null, 8, Vi)) : renderSlot(a.$slots, "default", { key: 1 }, () => [
          createTextVNode(toDisplayString(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var vn = defineComponent({
  __name: "BCardHeader",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (l, a) => (openBlock(), createBlock(fn, mergeProps({ class: "card-header" }, t), {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var pn = defineComponent({
  __name: "BCardTitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, l) => (openBlock(), createBlock(resolveDynamicComponent(t.tag), { class: "card-title" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var mn = defineComponent({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null
    }));
    return (a, o) => (openBlock(), createBlock(resolveDynamicComponent(a.tag), {
      class: normalizeClass(["card-subtitle mb-2", l.value])
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var gn = defineComponent({
  __name: "BCardBody",
  props: {
    bodyBgVariant: { default: null },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: null },
    overlay: { type: [String, Boolean], default: false },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(e) {
    const t = e, l = useSlots(), a = d(() => t.overlay), o = computed(() => !Fe(l.title)), n = computed(() => !Fe(l.subtitle)), s = computed(() => ({
      "card-img-overlay": a.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== null,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== null
    }));
    return (r, u) => (openBlock(), createBlock(resolveDynamicComponent(r.bodyTag), {
      class: normalizeClass(["card-body", s.value])
    }, {
      default: withCtx(() => [
        r.title || o.value ? (openBlock(), createBlock(pn, {
          key: 0,
          tag: r.titleTag
        }, {
          default: withCtx(() => [
            renderSlot(r.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(r.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : createCommentVNode("", true),
        r.subtitle || n.value ? (openBlock(), createBlock(mn, {
          key: 1,
          tag: r.subtitleTag,
          "text-variant": r.subtitleTextVariant
        }, {
          default: withCtx(() => [
            renderSlot(r.$slots, "subtitle", {}, () => [
              createTextVNode(toDisplayString(r.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : createCommentVNode("", true),
        renderSlot(r.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(r.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var yn = defineComponent({
  __name: "BCardFooter",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (l, a) => (openBlock(), createBlock(fn, mergeProps({ class: "card-footer" }, t), {
      default: withCtx(() => [
        renderSlot(l.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(l.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
});
var bn = defineComponent({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bgVariant: { default: null },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBottom: { type: [String, Boolean], default: false },
    imgEnd: { type: [String, Boolean], default: false },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { type: [String, Boolean], default: false },
    imgTop: { type: [String, Boolean], default: false },
    imgWidth: { default: void 0 },
    noBody: { type: [String, Boolean], default: false },
    overlay: { type: [String, Boolean], default: false },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: { default: null },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, l = useSlots(), a = d(() => t.imgBottom), o = d(() => t.imgEnd), n = d(() => t.imgStart), s = d(() => t.noBody), r = computed(() => !Fe(l.header)), u = computed(() => !Fe(l.footer)), f = computed(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== null,
      [`bg-${t.bgVariant}`]: t.bgVariant !== null,
      [`border-${t.borderVariant}`]: t.borderVariant !== null,
      "flex-row": n.value,
      "flex-row-reverse": o.value
    })), v = computed(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), p = computed(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subtitle: t.subtitle,
      subtitleTag: t.subtitleTag,
      subtitleTextVariant: t.subtitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), c = computed(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), g = computed(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (B, m) => (openBlock(), createBlock(resolveDynamicComponent(B.tag), {
      class: normalizeClass(["card", f.value])
    }, {
      default: withCtx(() => [
        unref(a) ? createCommentVNode("", true) : renderSlot(B.$slots, "img", { key: 0 }, () => [
          B.imgSrc ? (openBlock(), createBlock(ia, normalizeProps(mergeProps({ key: 0 }, g.value)), null, 16)) : createCommentVNode("", true)
        ]),
        B.header || r.value || B.headerHtml ? (openBlock(), createBlock(vn, mergeProps({ key: 1 }, v.value, { class: B.headerClass }), {
          default: withCtx(() => [
            renderSlot(B.$slots, "header", {}, () => [
              createTextVNode(toDisplayString(B.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : createCommentVNode("", true),
        unref(s) ? renderSlot(B.$slots, "default", { key: 3 }, () => [
          createTextVNode(toDisplayString(B.bodyText), 1)
        ]) : (openBlock(), createBlock(gn, mergeProps({ key: 2 }, p.value, { class: B.bodyClass }), {
          default: withCtx(() => [
            renderSlot(B.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(B.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        B.footer || u.value || B.footerHtml ? (openBlock(), createBlock(yn, mergeProps({ key: 4 }, c.value, { class: B.footerClass }), {
          default: withCtx(() => [
            renderSlot(B.$slots, "footer", {}, () => [
              createTextVNode(toDisplayString(B.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : createCommentVNode("", true),
        unref(a) ? renderSlot(B.$slots, "img", { key: 5 }, () => [
          B.imgSrc ? (openBlock(), createBlock(ia, normalizeProps(mergeProps({ key: 0 }, g.value)), null, 16)) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Oi = defineComponent({
  __name: "BCardGroup",
  props: {
    columns: { type: [String, Boolean], default: false },
    deck: { type: [String, Boolean], default: false },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = d(() => t.columns), a = d(() => t.deck), o = computed(
      () => a.value ? "card-deck" : l.value ? "card-columns" : "card-group"
    ), n = computed(() => [o.value]);
    return (s, r) => (openBlock(), createBlock(resolveDynamicComponent(s.tag), {
      class: normalizeClass(n.value)
    }, {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Ai = defineComponent({
  __name: "BCardText",
  props: {
    text: { default: void 0 },
    tag: { default: "p" }
  },
  setup(e) {
    return (t, l) => (openBlock(), createBlock(resolveDynamicComponent(t.tag), { class: "card-text" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var Pi = ["id", "onMouseenter", "onMouseleave"];
var Ei = {
  key: 0,
  class: "carousel-indicators"
};
var Fi = ["aria-current", "aria-label", "onClick"];
var Ii = createBaseVNode("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1);
var xi = { class: "visually-hidden" };
var Li = createBaseVNode("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1);
var Ni = { class: "visually-hidden" };
var zi = defineComponent({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: false },
    noHoverPause: { type: [String, Boolean], default: false },
    rideReverse: { type: [String, Boolean], default: false },
    fade: { type: [String, Boolean], default: false },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    background: { default: void 0 },
    modelValue: { default: 0 },
    controls: { type: [String, Boolean], default: false },
    indicators: { type: [String, Boolean], default: false },
    interval: { default: 5e3 },
    noTouch: { type: [String, Boolean], default: false },
    noWrap: { type: [String, Boolean], default: false },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { type: [String, Boolean], default: true },
    touchThreshold: { default: 50 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = useSlots(), n = Ve(() => a.id, "carousel"), s = ke(a, "modelValue", l, { passive: true }), r = d(() => a.keyboard), u = d(() => a.rideReverse), f = d(() => a.noHoverPause), v = d(() => a.fade), p = d(() => a.controls), c = d(() => a.indicators), g = d(() => a.noTouch), B = d(() => a.noWrap), m = bt(() => a.touchThreshold, {
      nanToZero: true,
      method: "parseInt"
    }), V = ref(false), b = ref(false), T = ref(true), _ = ref(null), h2 = ref(null), k = ref(s.value), C = computed(
      () => es(a.ride) ? Ma(a.ride) : a.ride
    ), w = computed(
      () => `carousel-item carousel-item-${T.value ? "prev" : "next"} carousel-item-${T.value ? "end" : "start"}`
    ), P = computed(
      () => `carousel-item active carousel-item-${T.value ? "start" : "end"}`
    ), { pause: F, resume: S } = Ko(
      () => {
        u.value ? G() : X();
      },
      () => a.interval,
      { immediate: C.value === "carousel" }
    ), I = computed(
      () => C.value === true && b.value === true || C.value === "carousel"
    ), x = computed(() => $a(o.default, "BCarouselSlide")), z = computed(() => [
      "carousel",
      "slide",
      "pointer-event",
      { "carousel-fade": v.value }
    ]), te = (ee) => {
      var ne;
      return new vo(ee, {
        componentId: n.value,
        cancelable: false,
        target: h2.value,
        direction: T.value ? "right" : "left",
        from: k.value,
        to: s.value,
        relatedTarget: ((ne = _.value) == null ? void 0 : ne.children[s.value]) ?? null
      });
    }, Q = (ee) => {
      if (V.value !== true) {
        if (C.value === true && (b.value = true), I.value === true && S(), T.value = !(ee < s.value), ee >= x.value.length) {
          if (B.value)
            return;
          s.value = 0;
          return;
        }
        if (ee < 0) {
          if (B.value)
            return;
          s.value = x.value.length - 1;
          return;
        }
        k.value = s.value, s.value = ee;
      }
    }, G = () => {
      Q(s.value - 1);
    }, X = () => {
      Q(s.value + 1);
    }, U = (ee) => {
      r.value !== false && ee();
    }, pe = () => {
      f.value || F();
    }, be = () => {
      I.value && S();
    }, { lengthX: he } = Ur(h2, {
      passive: true,
      onSwipeStart() {
        g.value !== true && F();
      },
      onSwipeEnd() {
        if (g.value === true)
          return;
        const ee = () => {
          I.value !== false && S();
        };
        if (he.value >= m.value) {
          X(), ee();
          return;
        }
        he.value <= -m.value && (G(), ee());
      }
    }), ye = () => {
      l("slide", te("slide")), V.value = true;
    }, q = () => {
      l("slid", te("slid")), V.value = false;
    };
    return watch(
      () => a.ride,
      () => {
        b.value = false;
      }
    ), t({ pause: F, resume: S, prev: G, next: X }), provide(_o, {
      background: readonly(toRef(a, "background")),
      width: readonly(toRef(a, "imgWidth")),
      height: readonly(toRef(a, "imgHeight"))
    }), (ee, ne) => (openBlock(), createElementBlock("div", {
      id: unref(n),
      ref_key: "element",
      ref: h2,
      class: normalizeClass(z.value),
      onKeydown: [
        ne[0] || (ne[0] = withKeys((ue) => U(G), ["left"])),
        ne[1] || (ne[1] = withKeys((ue) => U(X), ["right"]))
      ],
      onMouseenter: withModifiers(pe, ["stop"]),
      onMouseleave: withModifiers(be, ["stop"])
    }, [
      unref(c) ? (openBlock(), createElementBlock("div", Ei, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(x.value.length, (ue, N) => (openBlock(), createElementBlock("button", {
          key: N,
          type: "button",
          "data-bs-target": "",
          class: normalizeClass(N === unref(s) ? "active" : ""),
          "aria-current": N === unref(s) ? true : void 0,
          "aria-label": `${ee.indicatorsButtonLabel} ${N}`,
          onClick: (le) => Q(N)
        }, null, 10, Fi))), 128))
      ])) : createCommentVNode("", true),
      createBaseVNode("div", {
        ref_key: "relatedTarget",
        ref: _,
        class: "carousel-inner"
      }, [
        createVNode(TransitionGroup, {
          "enter-from-class": w.value,
          "enter-active-class": w.value,
          "enter-to-class": w.value,
          "leave-from-class": P.value,
          "leave-active-class": P.value,
          "leave-to-class": P.value,
          onBeforeLeave: ye,
          onAfterLeave: q
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(x.value, (ue, N) => withDirectives((openBlock(), createBlock(resolveDynamicComponent(ue), {
              key: N,
              class: normalizeClass({ active: N === unref(s) && V.value === false })
            }, null, 8, ["class"])), [
              [vShow, N === unref(s)]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      unref(p) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: G
        }, [
          Ii,
          createBaseVNode("span", xi, toDisplayString(ee.controlsPrevText), 1)
        ]),
        createBaseVNode("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: X
        }, [
          Li,
          createBaseVNode("span", Ni, toDisplayString(ee.controlsNextText), 1)
        ])
      ], 64)) : createCommentVNode("", true)
    ], 42, Pi));
  }
});
var Hi = ["innerHTML"];
var Ri = { key: 1 };
var Mi = ["innerHTML"];
var Di = { key: 1 };
var ji = defineComponent({
  __name: "BCarouselSlide",
  props: {
    imgSrc: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: [String, Boolean], default: false },
    imgBlankColor: { default: "transparent" },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, l = useSlots(), a = inject(_o, null), o = computed(() => t.text || t.textHtml || !Fe(l.text)), n = computed(() => t.caption || t.captionHtml || !Fe(l.caption)), s = computed(() => o.value || n.value || !Fe(l.default)), r = computed(() => ({
      background: `${t.background || (a == null ? void 0 : a.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), u = computed(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (f, v) => (openBlock(), createElementBlock("div", {
      class: "carousel-item",
      style: normalizeStyle(r.value)
    }, [
      renderSlot(f.$slots, "img", {}, () => {
        var p, c;
        return [
          createVNode(al, {
            class: "d-block w-100",
            alt: f.imgAlt,
            src: f.imgSrc,
            width: f.imgWidth || ((p = unref(a)) == null ? void 0 : p.width.value),
            height: f.imgHeight || ((c = unref(a)) == null ? void 0 : c.height.value),
            blank: f.imgBlank,
            "blank-color": f.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      s.value ? (openBlock(), createBlock(resolveDynamicComponent(f.contentTag), {
        key: 0,
        class: normalizeClass(["carousel-caption", u.value])
      }, {
        default: withCtx(() => [
          n.value ? (openBlock(), createBlock(resolveDynamicComponent(f.captionTag), { key: 0 }, {
            default: withCtx(() => [
              renderSlot(f.$slots, "caption", {}, () => [
                f.captionHtml ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  innerHTML: f.captionHtml
                }, null, 8, Hi)) : (openBlock(), createElementBlock("span", Ri, toDisplayString(f.caption), 1))
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          o.value ? (openBlock(), createBlock(resolveDynamicComponent(f.textTag), { key: 1 }, {
            default: withCtx(() => [
              renderSlot(f.$slots, "text", {}, () => [
                f.textHtml ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  innerHTML: f.textHtml
                }, null, 8, Mi)) : (openBlock(), createElementBlock("span", Di, toDisplayString(f.text), 1))
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          renderSlot(f.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : createCommentVNode("", true)
    ], 4));
  }
});
var Hl = ca("", [], { type: [Boolean, String, Number], default: false });
var Rl = ca("offset", [""], { type: [String, Number], default: null });
var Ml = ca("order", [""], { type: [String, Number], default: null });
var qi = defineComponent({
  name: "BCol",
  slots: Object,
  props: {
    col: { type: [Boolean, String], default: false },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Hl,
    offset: { type: [String, Number], default: null },
    ...Rl,
    order: { type: [String, Number], default: null },
    ...Ml,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Hl, propPrefix: "cols", classPrefix: "col" },
      { content: Rl, propPrefix: "offset" },
      { content: Ml, propPrefix: "order" }
    ], l = d(() => e.col), a = computed(
      () => t.flatMap((n) => So(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: computed(() => [
        a.value,
        {
          col: l.value || !a.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
var ll = (e, t) => {
  const l = e.__vccOpts || e;
  for (const [a, o] of t)
    l[a] = o;
  return l;
};
function Gi(e, t, l, a, o, n) {
  return openBlock(), createBlock(resolveDynamicComponent(e.tag), {
    class: normalizeClass(e.computedClasses)
  }, {
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
var Pt = ll(qi, [["render", Gi]]);
var pt = {
  autoHide: true,
  delay: 5e3,
  noCloseButton: false,
  pos: "top-right",
  value: true
};
var Dl = class {
  constructor(t) {
    Pe(this, "vm");
    Pe(this, "containerPositions");
    isReactive(t) ? this.vm = t : this.vm = reactive(t), this.containerPositions = computed(() => {
      const l = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((a) => {
        a.options.pos && l.add(a.options.pos);
      }), l;
    });
  }
  toasts(t) {
    return t ? computed(
      () => this.vm.toasts.filter((l) => {
        if (l.options.pos === t && l.options.value)
          return l;
      })
    ) : computed(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((l) => {
      if (l.options.id && !t.includes(l.options.id))
        return l;
    });
  }
  isRoot() {
    return this.vm.root ?? false;
  }
  show(t, l = pt) {
    const a = { id: lt(), ...pt, ...l }, o = {
      options: reactive(a),
      content: t
    };
    return this.vm.toasts.push(o), o;
  }
  info(t, l = pt) {
    return this.show(t, { variant: "info", ...l });
  }
  danger(t, l = pt) {
    return this.show(t, { variant: "danger", ...l });
  }
  warning(t, l = pt) {
    return this.show(t, { variant: "warning", ...l });
  }
  success(t, l = pt) {
    return this.show(t, { variant: "success", ...l });
  }
  hide() {
  }
};
var Wi = class {
  constructor() {
    Pe(this, "vms");
    Pe(this, "rootInstance");
    Pe(this, "useToast", Bn);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const l = { root: true, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = l.id, this.vms[l.id] = l, l;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
};
var Aa = Symbol("toast");
var hn = Symbol("toastFetch");
var Ui = {
  container: void 0,
  toasts: [],
  root: false
};
function Ki() {
  return inject(hn);
}
function Bn(e, t = Aa) {
  const l = inject(Ki());
  if (!e)
    return new Dl(l.getOrCreateViewModel());
  const a = { id: Symbol("toastInstance") }, o = { ...Ui, ...a, ...e }, n = l.getOrCreateViewModel(o);
  return new Dl(n);
}
var Sn = {
  install: (e, t) => {
    var a;
    const l = typeof (t == null ? void 0 : t.BToast) == "object" ? ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? Aa : Aa;
    e.provide(hn, l), e.provide(l, new Wi());
  }
};
var Xi = "toast-title";
var jl = 1e3;
var _n = defineComponent({
  components: { BLink: Qe },
  props: {
    ...fi,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String, default: void 0 },
    body: { type: [Object, String], default: void 0 },
    headerClass: { type: String, default: void 0 },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: true },
    id: { type: String, default: void 0 },
    // Switches role to 'status' and aria-live to 'polite'
    isStatus: { type: [Boolean, String], default: false },
    autoHide: { type: [Boolean, String], default: true },
    noCloseButton: { type: [Boolean, String], default: false },
    noFade: { type: [Boolean, String], default: false },
    noHoverPause: { type: [Boolean, String], default: false },
    solid: { type: [Boolean, String], default: false },
    // Render the toast in place, rather than in a portal-target
    static: { type: [Boolean, String], default: false },
    title: { type: String, default: void 0 },
    modelValue: { type: [Boolean, String], default: false },
    toastClass: { type: Array, default: void 0 },
    variant: { type: String, default: null }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: l }) {
    d(() => e.animation);
    const a = d(() => e.isStatus), o = d(() => e.autoHide), n = d(() => e.noCloseButton), s = d(() => e.noFade), r = d(() => e.noHoverPause);
    d(() => e.solid), d(() => e.static);
    const u = d(() => e.modelValue), f = ref(false), v = ref(false), p = ref(false), c = computed(() => ({
      [`b-toast-${e.variant}`]: e.variant !== null,
      show: p.value || f.value
    }));
    let g, B, m;
    const V = () => {
      typeof g > "u" || (clearTimeout(g), g = void 0);
    }, b = computed(
      () => (
        // Minimum supported duration is 1 second
        Math.max(ot(e.delay, 0), jl)
      )
    ), T = () => {
      u.value && (B = m = 0, V(), v.value = true, Gt(() => {
        p.value = false;
      }));
    }, _ = () => {
      V(), t("update:modelValue", true), B = m = 0, v.value = false, nextTick(() => {
        Gt(() => {
          p.value = true;
        });
      });
    }, h2 = () => {
      if (!o.value || r.value || !g || m)
        return;
      const x = Date.now() - B;
      x > 0 && (V(), m = Math.max(b.value - x, jl));
    }, k = () => {
      (!o.value || r.value || !m) && (m = B = 0), C();
    };
    watch(u, (x) => {
      x ? _() : T();
    });
    const C = () => {
      V(), o.value && (g = setTimeout(T, m || b.value), B = Date.now(), m = 0);
    }, w = () => {
      f.value = true, t("update:modelValue", true);
    }, P = () => {
      f.value = false, C();
    }, F = () => {
      f.value = true;
    }, S = () => {
      f.value = false, m = B = 0, t("update:modelValue", false);
    };
    onUnmounted(() => {
      V(), o.value && t("destroyed", e.id);
    }), onMounted(() => {
      nextTick(() => {
        u.value && Gt(() => {
          _();
        });
      });
    });
    const I = () => {
      nextTick(() => {
        Gt(() => {
          T();
        });
      });
    };
    return () => {
      const x = () => {
        const z = [], te = Me(Xi, { hide: T }, l);
        te ? z.push(h(te)) : e.title && z.push(h("strong", { class: "me-auto" }, e.title)), !n.value && z.length !== 0 && z.push(
          h(Ot, {
            class: ["btn-close"],
            onClick: () => {
              T();
            }
          })
        );
        const Q = [];
        if (z.length > 0 && Q.push(
          h(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => z }
          )
        ), Me("default", { hide: T }, l) || e.body) {
          const G = h(
            St(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: St(e) ? { click: I } : {}
            },
            Me("default", { hide: T }, l) || e.body
          );
          Q.push(G);
        }
        return h(
          "div",
          {
            class: ["toast", e.toastClass, c.value],
            tabindex: "0"
          },
          Q
        );
      };
      return h(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: v.value ? null : a.value ? "status" : "alert",
          "aria-live": v.value ? null : a.value ? "polite" : "assertive",
          "aria-atomic": v.value ? null : true,
          onmouseenter: h2,
          onmouseleave: k
        },
        [
          h(
            Vt,
            {
              noFade: s.value,
              onAfterEnter: P,
              onBeforeEnter: w,
              onAfterLeave: S,
              onBeforeLeave: F
            },
            () => [p.value ? x() : ""]
          )
        ]
      );
    };
  }
});
var Pa = defineComponent({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: { default: void 0 }
  },
  setup(e) {
    const t = e, l = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, a = computed(() => l[t.position]), o = (n) => {
      var s;
      (s = t.instance) == null || s.remove(n);
    };
    return (n, s) => {
      var r;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([[a.value], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList((r = n.instance) == null ? void 0 : r.toasts(n.position).value, (u) => (openBlock(), createBlock(_n, {
          id: u.options.id,
          key: u.options.id,
          modelValue: u.options.value,
          "onUpdate:modelValue": (f) => u.options.value = f,
          "auto-hide": u.options.autoHide,
          delay: u.options.delay,
          "no-close-button": u.options.noCloseButton,
          title: u.content.title,
          body: u.content.body,
          component: u.content.body,
          variant: u.options.variant,
          onDestroyed: o
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "auto-hide", "delay", "no-close-button", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
});
var Yi = defineComponent({
  slots: Object,
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: false },
    toast: { type: Object, default: void 0 },
    position: { type: String, default: void 0 }
  },
  setup(e, { slots: t, expose: l }) {
    const a = ref();
    let o;
    const n = computed(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return onMounted(() => {
      e.toast;
    }), e.toast && (o = Bn({ container: a, root: e.toast.root }), l({
      // ...toastInstance?.useMethods,
    })), () => {
      var r;
      const s = [];
      return o == null || o.containerPositions.value.forEach((u) => {
        s.push(h(Pa, { key: u, instance: o, position: u }));
      }), h("div", { class: [n.value, e.position], ref: a }, [
        ...s,
        (r = t.default) == null ? void 0 : r.call(t)
      ]);
    };
  },
  methods: {}
});
var Ji = { class: "visually-hidden" };
var Zi = ["aria-labelledby", "role"];
var wn = defineComponent({
  inheritAttrs: false,
  __name: "BDropdown",
  props: {
    ariaLabel: { default: void 0 },
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: "md" },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: true },
    block: { type: [String, Boolean], default: false },
    dark: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    isNav: { type: [String, Boolean], default: false },
    dropup: { type: [String, Boolean], default: false },
    dropend: { type: [String, Boolean], default: false },
    dropstart: { type: [String, Boolean], default: false },
    center: { type: [String, Boolean], default: false },
    end: { type: [String, Boolean], default: false },
    noFlip: { type: [String, Boolean], default: false },
    noShift: { type: [String, Boolean], default: false },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { type: [String, Boolean], default: false },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { type: [String, Boolean], default: void 0 },
    noCaret: { type: [String, Boolean], default: false },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    modelValue: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: false },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Ve(() => a.id, "dropdown"), n = ke(a, "modelValue", l, { passive: true }), s = d(n), r = d(() => a.block), u = d(() => a.dark), f = d(() => a.dropup), v = d(() => a.dropend), p = d(() => a.isNav), c = d(() => a.dropstart), g = d(() => a.center), B = d(() => a.end), m = d(() => a.split), V = d(() => a.noCaret), b = d(() => a.noFlip), T = d(() => a.noShift), _ = d(() => a.lazy), h2 = d(() => a.splitDisabled), k = computed(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), C = bt(k, { method: "parseInt", nanToZero: true }), w = ref(null), P = ref(null), F = ref(null), S = computed(() => m.value ? P.value : F.value), I = computed(
      () => ai({
        top: f.value,
        start: c.value,
        end: v.value,
        alignCenter: g.value,
        alignEnd: B.value
      })
    ), x = computed(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const N = typeof a.offset == "string" || typeof a.offset == "number" ? C.value : a.offset, le = [Io(N)];
      return b.value === false && le.push(Fo()), T.value === false && le.push(xo()), le;
    }), { x: z, y: te, strategy: Q, update: G } = Go(S, w, {
      placement: I,
      middleware: x,
      strategy: a.strategy
    }), X = computed(() => ({
      "d-grid": r.value,
      dropup: f.value,
      dropend: v.value,
      dropstart: c.value,
      "d-flex": r.value && m.value
    })), U = computed(() => [
      m.value ? a.splitClass : a.toggleClass,
      {
        "nav-link": p.value,
        "dropdown-toggle": !m.value,
        "dropdown-toggle-no-caret": V.value && !m.value,
        "w-100": m.value && r.value,
        show: m.value ? void 0 : s.value
      }
    ]), pe = computed(() => [
      a.menuClass,
      {
        "dropdown-menu-dark": u.value
      }
    ]), be = computed(() => ({
      "aria-label": a.ariaLabel,
      "aria-expanded": m.value ? void 0 : s.value,
      "aria-haspopup": m.value ? void 0 : "menu",
      href: m.value ? a.splitHref : void 0,
      to: m.value && a.splitTo ? a.splitTo : void 0
    })), he = () => {
      l("toggle");
      const N = s.value, le = new Je(N ? "hide" : "show");
      if (l(N ? "hide" : "show", le), le.defaultPrevented) {
        l(N ? "hide-prevented" : "show-prevented");
        return;
      }
      n.value = !N, l(N ? "hidden" : "shown");
    }, ye = (N) => {
      m.value ? l("click", N) : he();
    };
    Jo(
      w,
      () => {
        s.value && (a.autoClose === true || a.autoClose === "outside") && ue();
      },
      { ignore: [P, F] }
    );
    const q = () => {
      s.value && (a.autoClose === true || a.autoClose === "inside") && ue();
    }, ee = () => {
      n.value = false;
    }, ne = () => {
      n.value = true;
    }, ue = () => {
      n.value = !s.value;
    };
    return watch(s, G), t({
      close: ee,
      open: ne,
      toggle: ue
    }), provide(Ao, {
      id: o,
      open: ne,
      close: ee,
      toggle: ue,
      visible: s,
      isNav: p
    }), (N, le) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", mergeProps({
        class: [X.value, "btn-group"]
      }, N.$attrs), [
        createVNode(kt, mergeProps({
          id: unref(o),
          ref_key: "splitButton",
          ref: F,
          variant: N.splitVariant || N.variant,
          size: N.size,
          class: U.value,
          disabled: unref(h2) || N.disabled,
          type: N.splitButtonType
        }, be.value, {
          onClick: ye,
          onKeydown: le[0] || (le[0] = withKeys((de) => n.value = !unref(s), ["esc"]))
        }), {
          default: withCtx(() => [
            renderSlot(N.$slots, "button-content", {}, () => [
              createTextVNode(toDisplayString(N.text), 1)
            ])
          ]),
          _: 3
        }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
        unref(m) ? (openBlock(), createBlock(kt, {
          key: 0,
          ref_key: "button",
          ref: P,
          variant: N.variant,
          size: N.size,
          disabled: N.disabled,
          class: normalizeClass([[N.toggleClass, unref(s) ? "show" : void 0], "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": unref(s),
          "aria-haspopup": "menu",
          onClick: he
        }, {
          default: withCtx(() => [
            createBaseVNode("span", Ji, [
              renderSlot(N.$slots, "toggle-text", {}, () => [
                createTextVNode(toDisplayString(N.toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : createCommentVNode("", true)
      ], 16),
      !unref(_) || unref(s) ? withDirectives((openBlock(), createElementBlock("ul", {
        key: 0,
        ref_key: "floating",
        ref: w,
        style: normalizeStyle({
          position: unref(Q) === "absolute" ? void 0 : "fixed",
          top: `${unref(te)}px`,
          left: `${unref(z)}px`,
          width: "max-content"
        }),
        class: normalizeClass(["dropdown-menu show", pe.value]),
        "aria-labelledby": unref(o),
        role: N.role,
        onClick: q
      }, [
        renderSlot(N.$slots, "default")
      ], 14, Zi)), [
        [vShow, unref(_) || unref(s)]
      ]) : createCommentVNode("", true)
    ], 64));
  }
});
var Qi = { role: "presentation" };
var eu = defineComponent({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, l) => (openBlock(), createElementBlock("li", Qi, [
      (openBlock(), createBlock(resolveDynamicComponent(t.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
});
var tu = { role: "presentation" };
var au = { class: "px-4 py-3" };
var lu = defineComponent({
  __name: "BDropdownForm",
  setup(e) {
    return (t, l) => (openBlock(), createElementBlock("li", tu, [
      createBaseVNode("form", au, [
        renderSlot(t.$slots, "default")
      ])
    ]));
  }
});
var ou = { role: "presentation" };
var nu = ["id", "aria-describedby"];
var su = defineComponent({
  inheritAttrs: false,
  __name: "BDropdownGroup",
  props: {
    id: { default: void 0 },
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null }
  },
  setup(e) {
    const t = e, l = computed(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), a = computed(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), o = computed(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== null
      }
    ]);
    return (n, s) => (openBlock(), createElementBlock("li", ou, [
      (openBlock(), createBlock(resolveDynamicComponent(n.headerTag), {
        id: l.value,
        class: normalizeClass(["dropdown-header", o.value]),
        role: a.value
      }, {
        default: withCtx(() => [
          renderSlot(n.$slots, "header", {}, () => [
            createTextVNode(toDisplayString(n.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      createBaseVNode("ul", mergeProps({
        id: n.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": n.ariaDescribedby || l.value
      }), [
        renderSlot(n.$slots, "default")
      ], 16, nu)
    ]));
  }
});
var ru = { class: "dropdown-header" };
var iu = defineComponent({
  __name: "BDropdownHeader",
  setup(e) {
    return (t, l) => (openBlock(), createElementBlock("li", null, [
      createBaseVNode("h6", ru, [
        renderSlot(t.$slots, "default")
      ])
    ]));
  }
});
var uu = defineComponent({
  inheritAttrs: false,
  __name: "BDropdownItem",
  props: {
    href: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = useAttrs(), s = computed(() => [
      l.linkClass,
      {
        active: a.value,
        disabled: o.value,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), r = computed(
      () => l.href ? "a" : n.to ? Qe : "button"
    ), u = computed(() => ({
      disabled: o.value,
      "aria-current": a.value ? true : null,
      href: r.value === "a" ? l.href : null,
      rel: l.rel,
      type: r.value === "button" ? "button" : null,
      target: l.target,
      ...n.to ? { activeClass: "active", ...n } : n
    })), f = inject(Wa, null), v = inject(Ao, null), p = inject(Ua, null), c = (g) => {
      var B, m;
      t("click", g), p !== null && ((B = f == null ? void 0 : f.close) == null || B.call(f)), (m = v == null ? void 0 : v.close) == null || m.call(v);
    };
    return (g, B) => (openBlock(), createElementBlock("li", {
      role: "presentation",
      class: normalizeClass(g.$attrs.class)
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(r.value), mergeProps({
        class: ["dropdown-item", s.value]
      }, u.value, { onClick: c }), {
        default: withCtx(() => [
          renderSlot(g.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
});
var du = ["disabled"];
var cu = defineComponent({
  inheritAttrs: false,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: { default: void 0 },
    active: { type: [String, Boolean], default: false },
    activeClass: { default: "active" },
    disabled: { type: [String, Boolean], default: false },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = computed(() => [
      l.buttonClass,
      {
        [l.activeClass]: a.value,
        disabled: o.value,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), s = (r) => t("click", r);
    return (r, u) => (openBlock(), createElementBlock("li", {
      role: "presentation",
      class: normalizeClass(r.$attrs.class)
    }, [
      createBaseVNode("button", {
        role: "menu",
        type: "button",
        class: normalizeClass(["dropdown-item", n.value]),
        disabled: unref(o),
        onClick: s
      }, [
        renderSlot(r.$slots, "default")
      ], 10, du)
    ], 2));
  }
});
var fu = { role: "presentation" };
var vu = { class: "px-4 py-1 mb-0 text-muted" };
var pu = defineComponent({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, l) => (openBlock(), createElementBlock("li", fu, [
      createBaseVNode("p", vu, [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(t.text), 1)
        ])
      ])
    ]));
  }
});
var mu = ["id", "novalidate", "onSubmit"];
var $n = defineComponent({
  __name: "BForm",
  props: {
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: false },
    novalidate: { type: [String, Boolean], default: false },
    validated: { type: [String, Boolean], default: false }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.floating), o = d(() => l.novalidate), n = d(() => l.validated), s = computed(() => ({
      "form-floating": a.value,
      "was-validated": n.value
    })), r = (u) => t("submit", u);
    return (u, f) => (openBlock(), createElementBlock("form", {
      id: u.id,
      novalidate: unref(o),
      class: normalizeClass(s.value),
      onSubmit: withModifiers(r, ["prevent"])
    }, [
      renderSlot(u.$slots, "default")
    ], 42, mu));
  }
});
var gu = { class: "form-floating" };
var yu = ["for"];
var bu = defineComponent({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: { default: void 0 },
    label: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (openBlock(), createElementBlock("div", gu, [
      renderSlot(t.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(t.text), 1)
      ]),
      createBaseVNode("label", { for: t.labelFor }, [
        renderSlot(t.$slots, "label", {}, () => [
          createTextVNode(toDisplayString(t.label), 1)
        ])
      ], 8, yu)
    ]));
  }
});
var Ea = defineComponent({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: false },
    id: { default: void 0 },
    text: { default: void 0 },
    role: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.forceShow), a = d(() => t.state), o = d(() => t.tooltip), n = computed(
      () => l.value === true || a.value === false
    ), s = computed(() => ({
      "d-block": n.value,
      "invalid-feedback": !o.value,
      "invalid-tooltip": o.value
    })), r = computed(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? true : void 0
    }));
    return (u, f) => (openBlock(), createBlock(resolveDynamicComponent(u.tag), mergeProps({ class: s.value }, r.value), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(u.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var Zt = defineComponent({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, l) => (openBlock(), createBlock(resolveDynamicComponent(t.tag), { class: "row d-flex flex-wrap" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var Fa = defineComponent({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: [String, Boolean], default: false },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, l = d(() => t.inline), a = computed(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      "form-text": !l.value
    }));
    return (o, n) => (openBlock(), createBlock(resolveDynamicComponent(o.tag), {
      id: o.id,
      class: normalizeClass(a.value)
    }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var Ia = defineComponent({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: false },
    id: { default: void 0 },
    role: { default: void 0 },
    text: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.forceShow), a = d(() => t.state), o = d(() => t.tooltip), n = computed(
      () => l.value === true || a.value === true
    ), s = computed(() => ({
      "d-block": n.value,
      "valid-feedback": !o.value,
      "valid-tooltip": o.value
    })), r = computed(() => t.ariaLive ? true : void 0);
    return (u, f) => (openBlock(), createBlock(resolveDynamicComponent(u.tag), {
      id: u.id,
      role: u.role,
      "aria-live": u.ariaLive,
      "aria-atomic": r.value,
      class: normalizeClass(s.value)
    }, {
      default: withCtx(() => [
        renderSlot(u.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(u.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
});
var hu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"];
var Bu = ["for"];
var kn = defineComponent({
  inheritAttrs: false,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledBy: { default: void 0 },
    form: { default: void 0 },
    indeterminate: { type: [String, Boolean], default: void 0 },
    name: { default: void 0 },
    id: { default: void 0 },
    autofocus: { type: [String, Boolean], default: false },
    plain: { type: [String, Boolean], default: false },
    button: { type: [String, Boolean], default: false },
    buttonGroup: { type: [String, Boolean], default: false },
    switch: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: void 0 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: false },
    value: { type: [Array, Set, Boolean, String, Object, Number, null], default: true },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = useSlots(), n = ke(a, "modelValue", l, { passive: true }), s = Ve(() => a.id, "form-check"), r = d(() => a.indeterminate), u = d(() => a.autofocus), f = d(() => a.plain), v = d(() => a.button), p = d(() => a.buttonGroup), c = d(() => a.switch), g = d(() => a.disabled), B = d(() => a.inline), m = d(() => a.required), V = d(() => a.state), b = inject(Vo, null), T = ref(null), { focused: _ } = ze(T, {
      initialValue: u.value
    }), h2 = computed(() => !Fe(o.default)), k = computed({
      get: () => b !== null ? b.modelValue.value.map((x) => JSON.stringify(x)).includes(JSON.stringify(a.value)) : JSON.stringify(n.value) === JSON.stringify(a.value),
      set: (x) => {
        const z = x ? a.value : a.uncheckedValue;
        l("input", z), n.value = z, nextTick(() => {
          l("change", z);
        });
      }
    });
    watch(n, (x) => {
      if (b !== null) {
        if (x === false) {
          b.remove(a.value);
          return;
        }
        b.set(a.value);
      }
    });
    const C = computed(
      () => !!(a.name ?? (b == null ? void 0 : b.name.value)) && (m.value || (b == null ? void 0 : b.required.value))
    ), w = computed(
      () => p.value || ((b == null ? void 0 : b.buttons.value) ?? false)
    ), P = computed(() => ({
      plain: f.value || ((b == null ? void 0 : b.plain.value) ?? false),
      button: v.value || ((b == null ? void 0 : b.buttons.value) ?? false),
      inline: B.value || ((b == null ? void 0 : b.inline.value) ?? false),
      switch: c.value || ((b == null ? void 0 : b.switch.value) ?? false),
      state: V.value || (b == null ? void 0 : b.state.value),
      size: a.size !== void 0 ? a.size : (b == null ? void 0 : b.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (b == null ? void 0 : b.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), F = en(P), S = tn(P), I = an(P);
    return t({
      focus: () => {
        _.value = true;
      },
      blur: () => {
        _.value = false;
      }
    }), (x, z) => (openBlock(), createBlock(Qa, {
      skip: w.value,
      class: normalizeClass(unref(F))
    }, {
      default: withCtx(() => {
        var te, Q, G;
        return [
          withDirectives(createBaseVNode("input", mergeProps({ id: unref(s) }, x.$attrs, {
            ref_key: "input",
            ref: T,
            "onUpdate:modelValue": z[0] || (z[0] = (X) => k.value = X),
            class: unref(S),
            type: "checkbox",
            disabled: unref(g) || ((te = unref(b)) == null ? void 0 : te.disabled.value),
            required: C.value || void 0,
            name: x.name || ((Q = unref(b)) == null ? void 0 : Q.name.value),
            form: x.form || ((G = unref(b)) == null ? void 0 : G.form.value),
            "aria-label": x.ariaLabel,
            "aria-labelledby": x.ariaLabelledBy,
            "aria-required": C.value || void 0,
            value: x.value,
            indeterminate: unref(r)
          }), null, 16, hu), [
            [vModelCheckbox, k.value]
          ]),
          h2.value || unref(f) === false ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: unref(s),
            class: normalizeClass(unref(I))
          }, [
            renderSlot(x.$slots, "default")
          ], 10, Bu)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
});
var Su = ["id"];
var _u = ["innerHTML"];
var wu = ["textContent"];
var $u = defineComponent({
  __name: "BFormCheckboxGroup",
  props: {
    id: { default: void 0 },
    form: { default: void 0 },
    modelValue: { default: () => [] },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: false },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    size: { default: "md" },
    stacked: { type: [String, Boolean], default: false },
    state: { type: [String, Boolean, null], default: null },
    switches: { type: [String, Boolean], default: false },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: false },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = ke(a, "modelValue", l), n = Ve(() => a.id, "checkbox"), s = Ve(() => a.name, "checkbox"), r = d(() => a.autofocus), u = d(() => a.buttons), f = d(() => a.disabled), v = d(() => a.plain), p = d(() => a.required), c = d(() => a.stacked), g = d(() => a.state), B = d(() => a.switches), m = d(() => a.validated), V = ref(null), { focused: b } = ze(V, {
      initialValue: r.value
    });
    provide(Vo, {
      set: (C) => {
        const w = [...o.value];
        w.push(C), l("input", w), o.value = w, nextTick(() => {
          l("change", w);
        });
      },
      remove: (C) => {
        const w = [...o.value];
        w.splice(o.value.indexOf(C), 1), l("input", w), o.value = w, nextTick(() => {
          l("change", w);
        });
      },
      modelValue: computed(() => o.value),
      switch: B,
      buttonVariant: readonly(toRef(a, "buttonVariant")),
      form: readonly(toRef(a, "form")),
      name: s,
      state: g,
      plain: v,
      size: readonly(toRef(a, "size")),
      inline: computed(() => !c.value),
      required: p,
      buttons: u,
      disabled: f
    });
    const T = computed(
      () => a.options.map(
        (C, w) => typeof C == "string" || typeof C == "number" ? {
          props: {
            value: C,
            disabled: f.value
          },
          text: C.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${w}`)
        } : {
          props: {
            value: C[a.valueField],
            disabled: C[a.disabledField],
            ...C.props ? C.props : {}
          },
          text: C[a.textField],
          html: C[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${w}`)
        }
      )
    ), _ = computed(() => ({
      required: p.value,
      ariaInvalid: a.ariaInvalid,
      state: g.value,
      validated: m.value,
      buttons: u.value,
      stacked: c.value,
      size: a.size
    })), h2 = ln(_), k = on(_);
    return t({
      focus: () => {
        b.value = true;
      },
      blur: () => {
        b.value = false;
      }
    }), (C, w) => (openBlock(), createElementBlock("div", mergeProps(unref(h2), {
      id: unref(n),
      ref_key: "element",
      ref: V,
      role: "group",
      class: [unref(k), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      renderSlot(C.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(T.value, (P) => (openBlock(), createBlock(kn, mergeProps({
        key: P.self
      }, P.props), {
        default: withCtx(() => [
          P.html ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: P.html
          }, null, 8, _u)) : (openBlock(), createElementBlock("span", {
            key: 1,
            textContent: toDisplayString(P.text)
          }, null, 8, wu))
        ]),
        _: 2
      }, 1040))), 128)),
      renderSlot(C.$slots, "default")
    ], 16, Su));
  }
});
var ku = ["for"];
var Cu = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-required", "directory", "webkitdirectory"];
var Tu = defineComponent({
  inheritAttrs: false,
  __name: "BFormFile",
  props: {
    accept: { default: "" },
    autofocus: { type: [String, Boolean], default: false },
    capture: { type: [Boolean, String], default: false },
    directory: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    form: { default: void 0 },
    id: { default: void 0 },
    multiple: { type: [String, Boolean], default: false },
    name: { default: void 0 },
    noDrop: { type: [String, Boolean], default: false },
    noTraverse: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    modelValue: { default: null },
    label: { default: "" },
    labelClasses: { default: void 0 }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = useSlots(), n = ke(a, "modelValue", l), s = Ve(() => a.id), r = d(() => a.autofocus), u = d(() => a.directory), f = d(() => a.disabled), v = d(() => a.multiple), p = d(() => a.noDrop);
    d(() => a.noTraverse);
    const c = d(() => a.required), g = d(() => a.state), B = Tt(g), m = ref(null), { focused: V } = ze(m, { initialValue: r.value }), b = computed(() => !Fe(o.label)), T = computed(
      () => typeof a.accept == "string" ? a.accept : a.accept.join(",")
    ), _ = computed(
      () => a.capture === "user" || a.capture === "environment" ? a.capture : Ma(a.capture)
    ), h2 = computed(() => [
      B.value,
      {
        [`form-control-${a.size}`]: a.size !== void 0
      }
    ]), k = (P) => {
      var S, I;
      const F = ((S = m.value) == null ? void 0 : S.files) === null || ((I = m.value) == null ? void 0 : I.files) === void 0 ? null : [...m.value.files];
      n.value = F === null ? null : v.value === true ? F : F[0], l("change", P);
    }, C = (P) => {
      p.value === true && P.preventDefault();
    }, w = () => {
      n.value = null;
    };
    return watch(n, (P) => {
      P === null && m.value !== null && (m.value.value = "");
    }), t({
      focus: () => {
        V.value = true;
      },
      blur: () => {
        V.value = false;
      },
      reset: w
    }), (P, F) => (openBlock(), createElementBlock(Fragment, null, [
      b.value || P.label ? (openBlock(), createElementBlock("label", {
        key: 0,
        for: unref(s),
        class: normalizeClass(["form-label", P.labelClasses])
      }, [
        renderSlot(P.$slots, "label", {}, () => [
          createTextVNode(toDisplayString(P.label), 1)
        ])
      ], 10, ku)) : createCommentVNode("", true),
      createBaseVNode("input", mergeProps({ id: unref(s) }, P.$attrs, {
        ref_key: "input",
        ref: m,
        type: "file",
        class: ["form-control", h2.value],
        form: P.form,
        name: P.name,
        multiple: unref(v),
        disabled: unref(f),
        capture: _.value,
        accept: T.value || void 0,
        required: unref(c) || void 0,
        "aria-required": unref(c) || void 0,
        directory: unref(u),
        webkitdirectory: unref(u),
        onChange: k,
        onDrop: C
      }), null, 16, Cu)
    ], 64));
  }
});
var Cn = ["input", "select", "textarea"];
var Vu = Cn.map((e) => `${e}:not([disabled])`).join();
var Ou = [...Cn, "a", "button", "label"];
var Au = "label";
var Pu = "invalid-feedback";
var Eu = "valid-feedback";
var Fu = "description";
var Iu = "default";
var xu = defineComponent({
  components: { BCol: Pt, BFormInvalidFeedback: Ea, BFormRow: Zt, BFormText: Fa, BFormValidFeedback: Ia },
  props: {
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: false },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: false },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: false },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: false },
    floating: { type: [Boolean, String], default: false }
  },
  setup(e, { attrs: t }) {
    const l = d(() => e.disabled), a = d(() => e.labelSrOnly), o = d(() => e.state), n = d(() => e.tooltip), s = d(() => e.validated), r = d(() => e.floating), u = null, f = ["xs", "sm", "md", "lg", "xl"], v = (k, C) => f.reduce((w, P) => {
      const F = vl(P === "xs" ? "" : P, `${C}Align`), S = k[F] || null;
      return S && (P === "xs" ? w.push(`text-${S}`) : w.push(`text-${P}-${S}`)), w;
    }, []), p = (k, C) => f.reduce((w, P) => {
      const F = vl(P === "xs" ? "" : P, `${C}Cols`);
      let S = k[F];
      return S = S === "" ? true : S || false, typeof S != "boolean" && S !== "auto" && (S = Es(S, 0), S = S > 0 ? S : false), S && (P === "xs" ? w[typeof S == "boolean" ? "col" : "cols"] = S : w[P || (typeof S == "boolean" ? "col" : "cols")] = S), w;
    }, {}), c = ref(), g = (k, C = null) => {
      if (qa && e.labelFor) {
        const w = ho(`#${fs(e.labelFor)}`, c);
        if (w) {
          const P = "aria-describedby", F = (k || "").split(Yt), S = (C || "").split(Yt), I = (Ga(w, P) || "").split(Yt).filter((x) => !S.includes(x)).concat(F).filter((x, z, te) => te.indexOf(x) === z).filter((x) => x).join(" ").trim();
          I ? Vs(w, P, I) : Os(w, P);
        }
      }
    }, B = computed(() => p(e, "content")), m = computed(() => v(e, "label")), V = computed(() => p(e, "label")), b = computed(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(B.value).length > 0 || Object.keys(V.value).length > 0
      )
    ), T = Tt(o), _ = computed(
      () => fa(t.ariaInvalid, o.value)
    );
    return watch(
      () => u,
      (k, C) => {
        k !== C && g(k, C);
      }
    ), onMounted(() => {
      nextTick(() => {
        g(u);
      });
    }), {
      disabledBoolean: l,
      labelSrOnlyBoolean: a,
      stateBoolean: o,
      tooltipBoolean: n,
      validatedBoolean: s,
      floatingBoolean: r,
      ariaDescribedby: u,
      computedAriaInvalid: _,
      contentColProps: B,
      isHorizontal: b,
      labelAlignClasses: m,
      labelColProps: V,
      onLegendClick: (k) => {
        if (e.labelFor)
          return;
        const { target: C } = k, w = C ? C.tagName : "";
        if (Ou.indexOf(w) !== -1)
          return;
        const P = Cs(Vu, c).filter(ks);
        P.length === 1 && ws(P[0]);
      },
      stateClass: T
    };
  },
  render() {
    const e = this.$props, t = this.$slots, l = Ve(), a = !e.labelFor;
    let o = null;
    const n = Me(Au, {}, t) || e.label, s = n ? lt("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const h2 = a ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (o = h(
          h2,
          {
            class: "visually-hidden",
            id: s,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? o = h(Pt, this.labelColProps, { default: () => o }) : o = h("div", {}, [o]);
      else {
        const k = {
          onClick: a ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? h2 : null,
          id: s,
          for: e.labelFor || null,
          tabIndex: a ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": a,
              "col-form-label": this.isHorizontal || a,
              "pt-0": !this.isHorizontal && a,
              "d-block": !this.isHorizontal && !a,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? o = h(Pt, k, { default: () => n }) : o = h(h2, k, n);
      }
    }
    let r = null;
    const u = Me(Pu, {}, t) || this.invalidFeedback, f = u ? lt("_BV_feedback_invalid_") : void 0;
    u && (r = h(
      Ea,
      {
        ariaLive: e.feedbackAriaLive,
        id: f,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => u }
    ));
    let v = null;
    const p = Me(Eu, {}, t) || this.validFeedback, c = p ? lt("_BV_feedback_valid_") : void 0;
    p && (v = h(
      Ia,
      {
        ariaLive: e.feedbackAriaLive,
        id: c,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => p }
      // validFeedbackContent
    ));
    let g = null;
    const B = Me(Fu, {}, t) || this.description, m = B ? lt("_BV_description_") : void 0;
    B && (g = h(
      Fa,
      {
        id: m
      },
      { default: () => B }
    ));
    const V = this.ariaDescribedby = [
      m,
      this.stateBoolean === false ? f : null,
      this.stateBoolean === true ? c : null
    ].filter((h2) => h2).join(" ") || null, b = [
      Me(Iu, { ariaDescribedby: V, descriptionId: m, id: l, labelId: s }, t) || "",
      r,
      v,
      g
    ];
    !this.isHorizontal && this.floatingBoolean && b.push(o);
    let T = h(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      b
    );
    this.isHorizontal && (T = h(Pt, { ref: "content", ...this.contentColProps }, { default: () => b }));
    const _ = {
      class: [
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: Ve(() => e.id).value,
      disabled: a ? this.disabledBoolean : null,
      role: a ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": a && this.isHorizontal ? s : null
    };
    return this.isHorizontal && !a ? h(Zt, _, { default: () => [o, T] }) : h(
      a ? "fieldset" : "div",
      _,
      this.isHorizontal && a ? [h(Zt, null, { default: () => [o, T] })] : this.isHorizontal || !this.floatingBoolean ? [o, T] : [T]
    );
  }
});
var Lu = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
var Nu = defineComponent({
  __name: "BFormInput",
  props: {
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [String, Boolean], default: false },
    lazyFormatter: { type: [String, Boolean], default: false },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [String, Boolean], default: false },
    placeholder: { default: void 0 },
    plaintext: { type: [String, Boolean], default: false },
    readonly: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    trim: { type: [String, Boolean], default: false }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { expose: t, emit: l }) {
    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: u, onBlur: f, focus: v, blur: p } = nn(a, l), c = d(() => a.disabled), g = d(() => a.required), B = d(() => a.readonly), m = d(() => a.plaintext), V = d(() => a.state), b = Tt(V), T = ref(false), _ = computed(() => {
      const h2 = a.type === "range", k = a.type === "color";
      return [
        b.value,
        {
          "form-control-highlighted": T.value,
          "form-range": h2,
          "form-control": k || !a.plaintext && !h2,
          "form-control-color": k,
          "form-control-plaintext": a.plaintext && !h2 && !k,
          [`form-control-${a.size}`]: !!a.size
        }
      ];
    });
    return t({
      focus: v,
      blur: p
    }), (h2, k) => (openBlock(), createElementBlock("input", {
      id: unref(n),
      ref_key: "input",
      ref: o,
      class: normalizeClass(_.value),
      name: h2.name || void 0,
      form: h2.form || void 0,
      type: h2.type,
      disabled: unref(c),
      placeholder: h2.placeholder,
      required: unref(g) || void 0,
      autocomplete: h2.autocomplete || void 0,
      readonly: unref(B) || unref(m),
      min: h2.min,
      max: h2.max,
      step: h2.step,
      list: h2.type !== "password" ? h2.list : void 0,
      "aria-required": unref(g) || void 0,
      "aria-invalid": unref(s),
      onInput: k[0] || (k[0] = (C) => unref(r)(C)),
      onChange: k[1] || (k[1] = (C) => unref(u)(C)),
      onBlur: k[2] || (k[2] = (C) => unref(f)(C))
    }, null, 42, Lu));
  }
});
var zu = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"];
var Hu = ["for"];
var Tn = defineComponent({
  inheritAttrs: false,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    size: { default: void 0 },
    autofocus: { type: [String, Boolean], default: false },
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    plain: { type: [String, Boolean], default: false },
    button: { type: [String, Boolean], default: false },
    buttonGroup: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    state: { type: [String, Boolean, null], default: null },
    value: { type: [String, Boolean, Object, Number], default: true }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = useSlots(), n = ke(a, "modelValue", l, { passive: true }), s = Ve(() => a.id, "form-check"), r = d(() => a.autofocus), u = d(() => a.plain), f = d(() => a.button), v = d(() => a.buttonGroup), p = d(() => a.disabled), c = d(() => a.inline), g = d(() => a.required), B = d(() => a.state), m = inject(Oo, null), V = ref(null), { focused: b } = ze(V, {
      initialValue: r.value
    }), T = computed(() => !Fe(o.default)), _ = computed({
      get: () => m !== null ? JSON.stringify(m.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(n.value) === JSON.stringify(a.value),
      set: (S) => {
        const I = S || S === "" || S === 0 ? a.value : false;
        l("input", I), n.value = I, nextTick(() => {
          l("change", I);
        });
      }
    });
    watch(
      () => m == null ? void 0 : m.modelValue.value,
      (S) => {
        JSON.stringify(S) === JSON.stringify(a.value) !== true && (_.value = false);
      }
    ), watch(n, (S) => {
      m === null || S === false || m.set(a.value);
    });
    const h2 = computed(
      () => !!(a.name ?? (m == null ? void 0 : m.name.value)) && (g.value || (m == null ? void 0 : m.required.value))
    ), k = computed(
      () => v.value || ((m == null ? void 0 : m.buttons.value) ?? false)
    ), C = computed(() => ({
      plain: u.value || ((m == null ? void 0 : m.plain.value) ?? false),
      button: f.value || ((m == null ? void 0 : m.buttons.value) ?? false),
      inline: c.value || ((m == null ? void 0 : m.inline.value) ?? false),
      state: B.value || (m == null ? void 0 : m.state.value),
      size: a.size !== void 0 ? a.size : (m == null ? void 0 : m.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (m == null ? void 0 : m.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), w = en(C), P = tn(C), F = an(C);
    return t({
      focus: () => {
        b.value = true;
      },
      blur: () => {
        b.value = false;
      }
    }), (S, I) => (openBlock(), createBlock(Qa, {
      skip: k.value,
      class: normalizeClass(unref(w))
    }, {
      default: withCtx(() => {
        var x, z, te;
        return [
          withDirectives(createBaseVNode("input", mergeProps({ id: unref(s) }, S.$attrs, {
            ref_key: "input",
            ref: V,
            "onUpdate:modelValue": I[0] || (I[0] = (Q) => _.value = Q),
            checked: _.value,
            class: unref(P),
            type: "radio",
            disabled: unref(p) || ((x = unref(m)) == null ? void 0 : x.disabled.value),
            required: h2.value || void 0,
            name: S.name || ((z = unref(m)) == null ? void 0 : z.name.value),
            form: S.form || ((te = unref(m)) == null ? void 0 : te.form.value),
            "aria-label": S.ariaLabel,
            "aria-labelledby": S.ariaLabelledby,
            value: S.value,
            "aria-required": h2.value || void 0
          }), null, 16, zu), [
            [vModelRadio, _.value]
          ]),
          T.value || unref(u) === false ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: unref(s),
            class: normalizeClass(unref(F))
          }, [
            renderSlot(S.$slots, "default")
          ], 10, Hu)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
});
var Ru = ["id"];
var Mu = ["innerHTML"];
var Du = ["textContent"];
var ju = defineComponent({
  __name: "BFormRadioGroup",
  props: {
    size: { default: "md" },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: false },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    stacked: { type: [String, Boolean], default: false },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: false },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = ke(a, "modelValue", l), n = Ve(() => a.id, "radio"), s = Ve(() => a.name, "checkbox"), r = d(() => a.autofocus), u = d(() => a.buttons), f = d(() => a.disabled), v = d(() => a.plain), p = d(() => a.required), c = d(() => a.stacked), g = d(() => a.state), B = d(() => a.validated), m = ref(null), { focused: V } = ze(m, {
      initialValue: r.value
    });
    provide(Oo, {
      set: (k) => {
        l("input", k), o.value = k, nextTick(() => {
          l("change", k);
        });
      },
      modelValue: computed(() => o.value),
      buttonVariant: readonly(toRef(a, "buttonVariant")),
      form: readonly(toRef(a, "form")),
      name: s,
      buttons: u,
      state: g,
      plain: v,
      size: readonly(toRef(a, "size")),
      inline: computed(() => !c.value),
      required: p,
      disabled: f
    });
    const b = computed(
      () => a.options.map(
        (k, C) => typeof k == "string" || typeof k == "number" ? {
          props: {
            value: k,
            disabled: f.value
          },
          text: k.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${C}`)
        } : {
          props: {
            value: k[a.valueField],
            disabled: k[a.disabledField],
            ...k.props ? k.props : {}
          },
          text: k[a.textField],
          html: k[a.htmlField],
          self: Symbol(`radioGroupOptionItem${C}`)
        }
      )
    ), T = computed(() => ({
      required: p.value,
      ariaInvalid: a.ariaInvalid,
      state: g.value,
      validated: B.value,
      buttons: u.value,
      stacked: c.value,
      size: a.size
    })), _ = ln(T), h2 = on(T);
    return t({
      focus: () => {
        V.value = true;
      },
      blur: () => {
        V.value = false;
      }
    }), (k, C) => (openBlock(), createElementBlock("div", mergeProps(unref(_), {
      id: unref(n),
      ref_key: "element",
      ref: m,
      role: "radiogroup",
      class: [unref(h2), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      renderSlot(k.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(b.value, (w) => (openBlock(), createBlock(Tn, mergeProps({
        key: w.self
      }, w.props), {
        default: withCtx(() => [
          w.html ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: w.html
          }, null, 8, Mu)) : (openBlock(), createElementBlock("span", {
            key: 1,
            textContent: toDisplayString(w.text)
          }, null, 8, Du))
        ]),
        _: 2
      }, 1040))), 128)),
      renderSlot(k.$slots, "default")
    ], 16, Ru));
  }
});
var qu = ["value", "disabled"];
var ol = defineComponent({
  __name: "BFormSelectOption",
  props: {
    value: { default: void 0 },
    disabled: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.disabled);
    return (a, o) => (openBlock(), createElementBlock("option", {
      value: a.value,
      disabled: unref(l)
    }, [
      renderSlot(a.$slots, "default")
    ], 8, qu));
  }
});
var Gu = ["label"];
var Vn = defineComponent({
  __name: "BFormSelectOptionGroup",
  props: {
    label: { default: void 0 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, l = computed(
      () => el(t.options, "BFormSelectOptionGroup", t)
    );
    return (a, o) => (openBlock(), createElementBlock("optgroup", { label: a.label }, [
      renderSlot(a.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(l.value, (n, s) => (openBlock(), createBlock(ol, mergeProps({
        key: s,
        value: n.value,
        disabled: n.disabled
      }, a.$attrs, {
        innerHTML: n.html || n.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      renderSlot(a.$slots, "default")
    ], 8, Gu));
  }
});
var Wu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"];
var Uu = defineComponent({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    multiple: { type: [String, Boolean], default: false },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = ke(a, "modelValue", l), n = Ve(() => a.id, "input"), s = d(() => a.autofocus), r = d(() => a.disabled), u = d(() => a.multiple), f = d(() => a.plain), v = d(() => a.required), p = d(() => a.state), c = Tt(p), g = ref(), { focused: B } = ze(g, {
      initialValue: s.value
    }), m = computed(() => [
      c.value,
      {
        "form-control": f.value,
        [`form-control-${a.size}`]: a.size !== "md" && f.value,
        "form-select": !f.value,
        [`form-select-${a.size}`]: a.size !== "md" && !f.value
      }
    ]), V = computed(
      () => a.selectSize || f.value ? a.selectSize : void 0
    ), b = computed(
      () => fa(a.ariaInvalid, p.value)
    ), T = computed(() => el(a.options, "BFormSelect", a)), _ = computed({
      get: () => o.value,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: (h2) => {
        l("input", h2), o.value = h2, nextTick(() => {
          l("change", h2);
        });
      }
    });
    return t({
      focus: () => {
        B.value = true;
      },
      blur: () => {
        B.value = false;
      }
    }), (h2, k) => withDirectives((openBlock(), createElementBlock("select", mergeProps({
      id: unref(n),
      ref_key: "input",
      ref: g
    }, h2.$attrs, {
      "onUpdate:modelValue": k[0] || (k[0] = (C) => _.value = C),
      class: m.value,
      name: h2.name,
      form: h2.form || void 0,
      multiple: unref(u) || void 0,
      size: V.value,
      disabled: unref(r),
      required: unref(v) || void 0,
      "aria-required": unref(v) || void 0,
      "aria-invalid": b.value
    }), [
      renderSlot(h2.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(T.value, (C, w) => (openBlock(), createElementBlock(Fragment, { key: w }, [
        Array.isArray(C.options) ? (openBlock(), createBlock(Vn, {
          key: 0,
          label: C.label,
          options: C.options
        }, null, 8, ["label", "options"])) : (openBlock(), createBlock(ol, {
          key: 1,
          value: C.value,
          disabled: C.disabled,
          innerHTML: C.html || C.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      renderSlot(h2.$slots, "default")
    ], 16, Wu)), [
      [vModelSelect, _.value]
    ]);
  }
});
var ql = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase());
var Ku = (e) => {
  const t = Qt(e).toLowerCase().replace(ss, "").split("-"), l = t.slice(0, 2).join("-"), [a] = t;
  return ql.includes(l) || ql.includes(a);
};
var Xu = (e) => bs ? Sa(e) ? e : { capture: !!e || false } : !!(Sa(e) ? e.capture : e);
var Yu = (e, t, l, a) => {
  e && e.addEventListener && e.addEventListener(t, l, Xu(a));
};
var Ju = (e, t, l, a) => {
  e && e.removeEventListener && e.removeEventListener(t, l, a);
};
var Gl = (e, t) => {
  (e ? Yu : Ju)(...t);
};
var Kt = (e, { preventDefault: t = true, propagation: l = true, immediatePropagation: a = false } = {}) => {
  t && e.preventDefault(), l && e.stopPropagation(), a && e.stopImmediatePropagation();
};
var xa = "ArrowDown";
var On = "End";
var An = "Home";
var Pn = "PageDown";
var En = "PageUp";
var La = "ArrowUp";
var Wl = 1;
var Ul = 100;
var Kl = 1;
var Xl = 500;
var Yl = 100;
var Jl = 10;
var Zl = 4;
var Ql = [La, xa, An, On, En, Pn];
var Zu = defineComponent({
  props: {
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: void 0 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    // V-model prop
    name: { type: String, default: "BFormSpinButton" },
    disabled: { type: [Boolean, String], default: false },
    placeholder: { type: String, default: void 0 },
    locale: { type: String, default: "locale" },
    form: { type: String, default: void 0 },
    inline: { type: Boolean, default: false },
    size: { type: String, default: void 0 },
    formatterFn: {
      type: Function,
      default: void 0
    },
    readonly: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    repeatDelay: {
      type: [String, Number],
      default: Xl
    },
    repeatInterval: {
      type: [String, Number],
      default: Yl
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: Zl
    },
    repeatThreshold: {
      type: [String, Number],
      default: Jl
    },
    required: { type: [Boolean, String], default: false },
    step: { type: [String, Number], default: Kl },
    min: { type: [String, Number], default: Wl },
    max: { type: [String, Number], default: Ul },
    wrap: { type: Boolean, default: false },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const l = ke(e, "modelValue", t), a = ref(false), o = computed(() => 1), n = () => {
      t("change", r.value);
    }, s = ref(null), r = computed({
      get: () => l.value === null ? s.value : l.value,
      set: (q) => {
        l.value === null ? s.value = q : l.value = q;
      }
    });
    let u, f, v = false;
    const p = computed(() => Et(e.step, Kl)), c = computed(() => Et(e.min, Wl)), g = computed(() => {
      const q = Et(e.max, Ul), ee = p.value, ne = c.value;
      return Math.floor((q - ne) / ee) * ee + ne;
    }), B = computed(() => {
      const q = ot(e.repeatDelay, 0);
      return q > 0 ? q : Xl;
    }), m = computed(() => {
      const q = ot(e.repeatInterval, 0);
      return q > 0 ? q : Yl;
    }), V = computed(
      () => Math.max(ot(e.repeatThreshold, Jl), 1)
    ), b = computed(
      () => Math.max(ot(e.repeatStepMultiplier, Zl), 1)
    ), T = computed(() => {
      const q = p.value;
      return Math.floor(q) === q ? 0 : (q.toString().split(".")[1] || "").length;
    }), _ = computed(() => Math.pow(10, T.value || 0)), h2 = computed(() => {
      const { value: q } = r;
      return q === null ? "" : q.toFixed(T.value);
    }), k = computed(() => {
      const q = [e.locale];
      return new Intl.NumberFormat(q).resolvedOptions().locale;
    }), C = computed(
      () => (
        //todo
        Ku(k.value)
      )
    ), w = () => {
      const q = T.value;
      return new Intl.NumberFormat(k.value, {
        style: "decimal",
        useGrouping: false,
        minimumIntegerDigits: 1,
        minimumFractionDigits: q,
        maximumFractionDigits: q,
        notation: "standard"
      }).format;
    }, P = computed(() => e.formatterFn ?? w()), F = computed(() => ({
      role: "group",
      lang: k.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), S = computed(() => l.value !== null || s.value !== null), I = computed(() => ({
      dir: C.value,
      spinId: o.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === false || !S.value && e.required ? true : null,
      "aria-required": e.required ? true : null,
      "aria-valuemin": c.value,
      "aria-valuemax": g.value,
      "aria-valuenow": r.value !== null ? r.value : null,
      "aria-valuetext": r.value !== null ? P.value(r.value) : null
    })), x = (q) => {
      let { value: ee } = r;
      if (!e.disabled && ee !== null) {
        const ne = p.value * q, ue = c.value, N = g.value, le = _.value, { wrap: de } = e;
        ee = Math.round((ee - ue) / ne) * ne + ue + ne, ee = Math.round(ee * le) / le, r.value = ee > N ? de ? ue : N : ee < ue ? de ? N : ue : ee;
      }
    }, z = (q = 1) => {
      r.value === null ? r.value = c.value : x(1 * q);
    }, te = (q = 1) => {
      r.value === null ? r.value = e.wrap ? g.value : c.value : x(-1 * q);
    }, Q = (q) => {
      const { code: ee, altKey: ne, ctrlKey: ue, metaKey: N } = q;
      if (!(e.disabled || e.readonly || ne || ue || N) && Ql.includes(ee)) {
        if (Kt(q, { propagation: false }), v)
          return;
        he(), [La, xa].includes(ee) ? (v = true, ee === La ? X(q, z) : ee === xa && X(q, te)) : ee === En ? z(b.value) : ee === Pn ? te(b.value) : ee === An ? r.value = c.value : ee === On && (r.value = g.value);
      }
    }, G = (q) => {
      const { code: ee, altKey: ne, ctrlKey: ue, metaKey: N } = q;
      e.disabled || e.readonly || ne || ue || N || Ql.includes(ee) && (Kt(q, { propagation: false }), he(), v = false, n());
    }, X = (q, ee) => {
      const { type: ne } = q || {};
      if (!e.disabled && !e.readonly) {
        if (U(q) && ne === "mousedown" && q.button)
          return;
        he(), ee(1);
        const ue = V.value, N = b.value, le = B.value, de = m.value;
        u = setTimeout(() => {
          let Se = 0;
          f = setInterval(() => {
            ee(Se < ue ? 1 : N), Se++;
          }, de);
        }, le);
      }
    };
    function U(q) {
      return q.type === "mouseup" || q.type === "mousedown";
    }
    const pe = (q) => {
      U(q) && q.type === "mouseup" && q.button || (Kt(q, { propagation: false }), he(), be(false), n());
    }, be = (q) => {
      try {
        Gl(q, [document.body, "mouseup", pe, false]), Gl(q, [document.body, "touchend", pe, false]);
      } catch {
        return 0;
      }
    }, he = () => {
      clearTimeout(u), clearInterval(f), u = void 0, f = void 0;
    }, ye = (q, ee, ne, ue, N, le, de) => {
      const Se = h(ne, {
        props: { scale: a.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": true }
      }), Ce = { hasFocus: a.value }, K = (ce) => {
        !e.disabled && !e.readonly && (Kt(ce, { propagation: false }), be(true), X(ce, q));
      };
      return h(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || le,
          "aria-disabled": e.disabled || e.readonly || le ? true : null,
          "aria-controls": o.value,
          "aria-label": ee || null,
          "aria-keyshortcuts": N || null,
          onmousedown: K,
          ontouchstart: K
          // 'ref': keyRef,
        },
        [Me(de, Ce) || Se]
      );
    };
    return () => {
      const q = ye(
        z,
        e.labelIncrement,
        h(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          h("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        false,
        "increment"
      ), ee = ye(
        te,
        e.labelDecrement,
        h(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          h("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        false,
        "decrement"
      ), ne = [];
      e.name && !e.disabled && ne.push(
        h("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          // TODO: Should this be set to '' if value is out of range?
          value: h2.value,
          key: "hidden"
        })
      );
      const ue = h(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...I.value,
          key: "output"
          // ref: 'spinner',
        },
        [
          h(
            "bdi",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore How can we narrow this type down
            S.value ? P.value(r.value) : e.placeholder || ""
          )
        ]
      );
      return h(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: a },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
            // this.stateClass //TODO
          ],
          ...F.value,
          onkeydown: Q,
          onkeyup: G
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          // 'focus': onFocusBlur, //TODO
          // 'blur': onFocusBlur, //TODO
        },
        e.vertical ? [q, ne, ue, ee] : [ee, ne, ue, q]
      );
    };
  }
});
var Qu = ["id"];
var Fn = defineComponent({
  __name: "BFormTag",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    disabled: { type: [String, Boolean], default: false },
    noRemove: { type: [String, Boolean], default: false },
    pill: { type: [String, Boolean], default: false },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const l = e, a = useSlots(), o = Ve(() => l.id), n = d(() => l.disabled), s = d(() => l.noRemove), r = d(() => l.pill), u = computed(
      () => {
        var p;
        return ((((p = a.default) == null ? void 0 : p.call(a)[0].children) ?? "").toString() || l.title) ?? "";
      }
    ), f = computed(() => `${o.value}taglabel__`), v = computed(() => ({
      [`bg-${l.variant}`]: l.variant !== null,
      "text-dark": l.variant !== null && ["warning", "info", "light"].includes(l.variant),
      "rounded-pill": r.value,
      disabled: n.value
    }));
    return (p, c) => (openBlock(), createBlock(resolveDynamicComponent(p.tag), {
      id: unref(o),
      title: u.value,
      class: normalizeClass(["badge b-form-tag d-inline-flex align-items-center mw-100", v.value]),
      "aria-labelledby": f.value
    }, {
      default: withCtx(() => [
        createBaseVNode("span", {
          id: f.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          renderSlot(p.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(u.value), 1)
          ])
        ], 8, Qu),
        !unref(n) && !unref(s) ? (openBlock(), createBlock(Ot, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": p.removeLabel,
          class: "b-form-tag-remove",
          white: p.variant !== null && !["warning", "info", "light"].includes(p.variant),
          "aria-describedby": f.value,
          "aria-controls": p.id,
          onClick: c[0] || (c[0] = (g) => t("remove", u.value))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
});
var ed = ["id"];
var td = ["id", "for", "aria-live"];
var ad = ["id", "aria-live"];
var ld = ["id"];
var od = ["aria-controls"];
var nd = {
  role: "group",
  class: "d-flex"
};
var sd = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"];
var rd = ["disabled"];
var id = {
  "aria-live": "polite",
  "aria-atomic": "true"
};
var ud = {
  key: 0,
  class: "d-block invalid-feedback"
};
var dd = {
  key: 1,
  class: "form-text text-muted"
};
var cd = {
  key: 2,
  class: "form-text text-muted"
};
var fd = ["name", "value"];
var vd = defineComponent({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: [String, Boolean], default: false },
    autofocus: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: { default: void 0 },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { type: [String, Boolean], default: false },
    noOuterFocus: { type: [String, Boolean], default: false },
    noTagRemove: { type: [String, Boolean], default: false },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    separator: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    size: { default: "md" },
    tagClass: { default: void 0 },
    tagPills: { type: [String, Boolean], default: false },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => true },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = ke(a, "modelValue", l), n = Ve(), s = d(() => a.addOnChange), r = d(() => a.autofocus), u = d(() => a.disabled), f = d(() => a.noAddOnEnter), v = d(() => a.noOuterFocus), p = d(() => a.noTagRemove), c = d(() => a.removeOnDelete), g = d(() => a.required), B = d(() => a.state), m = d(() => a.tagPills), V = Tt(B), b = ref(null), { focused: T } = ze(b, {
      initialValue: r.value
    }), _ = computed(() => a.inputId || `${n.value}input__`), h2 = ref(o.value), k = ref(""), C = ref(o.value.length > 0), w = ref(""), P = ref([]), F = ref([]), S = ref([]), I = computed(() => [
      V.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: u.value,
        focus: T.value
      }
    ]), x = computed(() => h2.value.includes(k.value)), z = computed(
      () => k.value === "" ? false : !a.tagValidator(k.value)
    ), te = computed(() => h2.value.length === a.limit), Q = computed(() => !z.value && !x.value), G = computed(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: ne,
      disableAddButton: Q.value,
      disabled: u.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: S.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: u.value,
        form: a.form,
        id: _,
        value: k
      },
      inputHandlers: {
        input: be,
        keydown: ye,
        change: he
      },
      inputId: _,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: F.value,
      isDuplicate: x.value,
      isInvalid: z.value,
      isLimitReached: te.value,
      limitTagsText: a.limitTagsText,
      limit: a.limit,
      noTagRemove: p.value,
      placeholder: a.placeholder,
      removeTag: ue,
      required: g.value,
      separator: a.separator,
      size: a.size,
      state: B.value,
      tagClass: a.tagClass,
      tagPills: m.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: h2.value
    }));
    watch(o, (N) => {
      h2.value = N;
    });
    const X = (N) => {
      if (u.value) {
        N.target.blur();
        return;
      }
      l("focusin", N);
    }, U = (N) => {
      u.value || v.value || (T.value = true, l("focus", N));
    }, pe = (N) => {
      T.value = false, l("blur", N);
    }, be = (N) => {
      var de, Se;
      const le = typeof N == "string" ? N : N.target.value;
      if (C.value = false, (de = a.separator) != null && de.includes(le.charAt(0)) && le.length > 0) {
        b.value && (b.value.value = "");
        return;
      }
      if (k.value = le, (Se = a.separator) != null && Se.includes(le.charAt(le.length - 1))) {
        ne(le.slice(0, le.length - 1));
        return;
      }
      P.value = a.tagValidator(le) && !x.value ? [le] : [], F.value = a.tagValidator(le) ? [] : [le], S.value = x.value ? [le] : [], l("tag-state", P.value, F.value, S.value);
    }, he = (N) => {
      s.value && (be(N), x.value || ne(k.value));
    }, ye = (N) => {
      if (N.key === "Enter" && !f.value) {
        ne(k.value);
        return;
      }
      (N.key === "Backspace" || N.key === "Delete") && c.value && k.value === "" && C.value && h2.value.length > 0 ? ue(h2.value[h2.value.length - 1]) : C.value = true;
    }, q = computed(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), ee = computed(() => {
      if (q.value)
        return new RegExp(`[${cs(q.value)}]+`);
    }), ne = (N) => {
      N = (N ?? k.value).trim();
      const le = ee.value ? N.split(ee.value).map((Ce) => Ce.trim()) : [N], de = [];
      for (const Ce of le)
        if (!(Ce === "" || x.value || !a.tagValidator(Ce))) {
          if (a.limit && te.value)
            break;
          de.push(Ce);
        }
      const Se = [...o.value, ...de];
      k.value = "", C.value = true, o.value = Se, l("input", Se), T.value = true;
    }, ue = (N) => {
      const le = h2.value.indexOf((N == null ? void 0 : N.toString()) ?? "");
      w.value = h2.value.splice(le, 1).toString(), o.value = h2.value;
    };
    return t({
      focus: () => {
        T.value = true;
      },
      blur: () => {
        T.value = false;
      }
    }), (N, le) => (openBlock(), createElementBlock("div", {
      id: unref(n),
      class: normalizeClass(["b-form-tags form-control h-auto", I.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: X,
      onFocusout: le[1] || (le[1] = (de) => l("focusout", de))
    }, [
      createBaseVNode("output", {
        id: `${unref(n)}selected_tags__`,
        class: "visually-hidden",
        for: _.value,
        "aria-live": unref(T) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, toDisplayString(h2.value.join(", ")), 9, td),
      createBaseVNode("div", {
        id: `${unref(n)}removed_tags__`,
        role: "status",
        "aria-live": unref(T) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + toDisplayString(N.tagRemovedLabel) + ") " + toDisplayString(w.value), 9, ad),
      renderSlot(N.$slots, "default", normalizeProps(guardReactiveProps(G.value)), () => [
        createBaseVNode("ul", {
          id: `${unref(n)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(h2.value, (de, Se) => renderSlot(N.$slots, "tag", normalizeProps(mergeProps({ key: Se }, { tag: de, tagClass: N.tagClass, tagVariant: N.tagVariant, tagPills: unref(m), removeTag: ue })), () => [
            (openBlock(), createBlock(Fn, {
              key: de,
              class: normalizeClass(N.tagClass),
              tag: "li",
              variant: N.tagVariant,
              pill: N.tagPills,
              onRemove: ue
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(de), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          createBaseVNode("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${unref(n)}tag_list__`
          }, [
            createBaseVNode("div", nd, [
              createBaseVNode("input", mergeProps({
                id: _.value,
                ref_key: "input",
                ref: b,
                disabled: unref(u),
                value: k.value,
                type: N.inputType,
                placeholder: N.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, N.inputAttrs, {
                form: N.form,
                required: unref(g) || void 0,
                "aria-required": unref(g) || void 0,
                onInput: be,
                onChange: he,
                onKeydown: ye,
                onFocus: U,
                onBlur: pe
              }), null, 16, sd),
              Q.value ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                class: normalizeClass(["btn b-form-tags-button py-0", [
                  N.inputClass,
                  {
                    [`btn-${N.addButtonVariant}`]: N.addButtonVariant !== null,
                    "disabled invisible": k.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: unref(u) || k.value.length === 0 || te.value,
                onClick: le[0] || (le[0] = (de) => ne(k.value))
              }, [
                renderSlot(N.$slots, "add-button-text", {}, () => [
                  createTextVNode(toDisplayString(N.addButtonText), 1)
                ])
              ], 10, rd)) : createCommentVNode("", true)
            ])
          ], 8, od)
        ], 8, ld),
        createBaseVNode("div", id, [
          z.value ? (openBlock(), createElementBlock("div", ud, toDisplayString(N.invalidTagText) + ": " + toDisplayString(k.value), 1)) : createCommentVNode("", true),
          x.value ? (openBlock(), createElementBlock("small", dd, toDisplayString(N.duplicateTagText) + ": " + toDisplayString(k.value), 1)) : createCommentVNode("", true),
          h2.value.length === N.limit ? (openBlock(), createElementBlock("small", cd, "Tag limit reached")) : createCommentVNode("", true)
        ])
      ]),
      N.name ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(h2.value, (de, Se) => (openBlock(), createElementBlock("input", {
        key: Se,
        type: "hidden",
        name: N.name,
        value: de
      }, null, 8, fd))), 128)) : createCommentVNode("", true)
    ], 42, ed));
  }
});
var pd = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
var md = defineComponent({
  __name: "BFormTextarea",
  props: {
    noResize: { type: [String, Boolean], default: false },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [String, Boolean], default: false },
    lazyFormatter: { type: [String, Boolean], default: false },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [String, Boolean], default: false },
    placeholder: { default: void 0 },
    plaintext: { type: [String, Boolean], default: false },
    readonly: { type: [String, Boolean], default: false },
    required: { type: [String, Boolean], default: false },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    trim: { type: [String, Boolean], default: false }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { expose: t, emit: l }) {
    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: u, onBlur: f, focus: v, blur: p } = nn(a, l), c = d(() => a.disabled), g = d(() => a.required), B = d(() => a.readonly), m = d(() => a.plaintext), V = d(() => a.noResize), b = d(() => a.state), T = Tt(b), _ = computed(() => [
      T.value,
      {
        "form-control": !a.plaintext,
        "form-control-plaintext": a.plaintext,
        [`form-control-${a.size}`]: !!a.size
      }
    ]), h2 = computed(() => ({
      resize: V.value ? "none" : void 0
    }));
    return t({
      focus: v,
      blur: p
    }), (k, C) => (openBlock(), createElementBlock("textarea", {
      id: unref(n),
      ref_key: "input",
      ref: o,
      class: normalizeClass(_.value),
      name: k.name || void 0,
      form: k.form || void 0,
      disabled: unref(c),
      placeholder: k.placeholder,
      required: unref(g) || void 0,
      autocomplete: k.autocomplete || void 0,
      readonly: unref(B) || unref(m),
      "aria-required": k.required || void 0,
      "aria-invalid": unref(s),
      rows: k.rows,
      style: normalizeStyle(h2.value),
      wrap: k.wrap || void 0,
      onInput: C[0] || (C[0] = (w) => unref(r)(w)),
      onChange: C[1] || (C[1] = (w) => unref(u)(w)),
      onBlur: C[2] || (C[2] = (w) => unref(f)(w))
    }, null, 46, pd));
  }
});
var gd = {
  key: 0,
  class: "input-group-text"
};
var yd = ["innerHTML"];
var bd = { key: 1 };
var hd = {
  key: 0,
  class: "input-group-text"
};
var Bd = ["innerHTML"];
var Sd = { key: 1 };
var _d = defineComponent({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`input-group-${t.size}`]: t.size !== "md"
    })), a = computed(() => !!t.append || !!t.appendHtml), o = computed(() => !!t.prepend || !!t.prependHtml);
    return (n, s) => (openBlock(), createBlock(resolveDynamicComponent(n.tag), {
      id: n.id,
      class: normalizeClass(["input-group", l.value]),
      role: "group"
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "prepend", {}, () => [
          o.value ? (openBlock(), createElementBlock("span", gd, [
            n.prependHtml ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: n.prependHtml
            }, null, 8, yd)) : (openBlock(), createElementBlock("span", bd, toDisplayString(n.prepend), 1))
          ])) : createCommentVNode("", true)
        ]),
        renderSlot(n.$slots, "default"),
        renderSlot(n.$slots, "append", {}, () => [
          a.value ? (openBlock(), createElementBlock("span", hd, [
            n.appendHtml ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: n.appendHtml
            }, null, 8, Bd)) : (openBlock(), createElementBlock("span", Sd, toDisplayString(n.append), 1))
          ])) : createCommentVNode("", true)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var In = defineComponent({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (openBlock(), createBlock(resolveDynamicComponent(t.tag), { class: "input-group-text" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var nl = defineComponent({
  __name: "BInputGroupAddon",
  props: {
    isText: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.isText);
    return (a, o) => unref(l) ? (openBlock(), createBlock(In, { key: 0 }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    })) : renderSlot(a.$slots, "default", { key: 1 });
  }
});
var wd = defineComponent({
  __name: "BInputGroupAppend",
  props: {
    isText: { type: [String, Boolean], default: false }
  },
  setup(e) {
    return (t, l) => (openBlock(), createBlock(nl, { "is-text": t.isText }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
});
var $d = defineComponent({
  __name: "BInputGroupPrepend",
  props: {
    isText: { type: [String, Boolean], default: false }
  },
  setup(e) {
    return (t, l) => (openBlock(), createBlock(nl, { "is-text": t.isText }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
});
var kd = defineComponent({
  __name: "BListGroup",
  props: {
    flush: { type: [String, Boolean], default: false },
    horizontal: { type: [Boolean, String], default: false },
    numbered: { type: [String, Boolean], default: false },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = d(() => t.flush), a = d(() => t.numbered), o = computed(() => {
      const s = l.value ? false : t.horizontal;
      return {
        "list-group-flush": l.value,
        "list-group-horizontal": s === true,
        [`list-group-horizontal-${s}`]: typeof s == "string",
        "list-group-numbered": a.value
      };
    }), n = computed(() => a.value === true ? "ol" : t.tag);
    return provide(ko, {
      numbered: a
    }), (s, r) => (openBlock(), createBlock(resolveDynamicComponent(n.value), {
      class: normalizeClass(["list-group", o.value])
    }, {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Cd = defineComponent({
  __name: "BListGroupItem",
  props: {
    action: { type: [String, Boolean], default: false },
    active: { type: [String, Boolean], default: false },
    button: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    href: { default: void 0 },
    tag: { default: "div" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = useAttrs(), a = inject(ko, null), o = d(() => t.action), n = d(() => t.active), s = d(() => t.button), r = d(() => t.disabled), u = computed(() => !s.value && (!!t.href || !!t.to)), f = computed(
      () => a != null && a.numbered.value ? "li" : s.value ? "button" : u.value ? Qe : t.tag
    ), v = computed(
      () => o.value || u.value || s.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), p = computed(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== null,
      "list-group-item-action": v.value,
      active: n.value,
      disabled: r.value
    })), c = computed(() => {
      const g = {};
      return s.value && ((!l || !l.type) && (g.type = "button"), r.value && (g.disabled = true)), g;
    });
    return (g, B) => (openBlock(), createBlock(resolveDynamicComponent(f.value), mergeProps({
      class: ["list-group-item", p.value],
      "aria-current": unref(n) ? true : void 0,
      "aria-disabled": unref(r) ? true : void 0,
      target: u.value ? g.target : void 0,
      href: unref(s) ? void 0 : g.href,
      to: unref(s) ? void 0 : g.to
    }, c.value), {
      default: withCtx(() => [
        renderSlot(g.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
});
var Td = ["id", "aria-labelledby", "aria-describedby"];
var Vd = ["id"];
var Od = defineComponent({
  inheritAttrs: false,
  __name: "BModal",
  props: {
    bodyBgVariant: { default: null },
    bodyClass: { default: void 0 },
    bodyTextVariant: { default: null },
    busy: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: false },
    buttonSize: { default: "md" },
    cancelDisabled: { type: [String, Boolean], default: false },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: [String, Boolean], default: false },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: false },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { type: [String, Boolean], default: false },
    headerTextVariant: { default: null },
    hideBackdrop: { type: [String, Boolean], default: false },
    hideFooter: { type: [String, Boolean], default: false },
    hideHeader: { type: [String, Boolean], default: false },
    hideHeaderClose: { type: [String, Boolean], default: false },
    id: { default: void 0 },
    modalClass: { default: void 0 },
    modelValue: { type: [String, Boolean], default: false },
    noCloseOnBackdrop: { type: [String, Boolean], default: false },
    noCloseOnEsc: { type: [String, Boolean], default: false },
    noFade: { type: [String, Boolean], default: false },
    autoFocus: { type: [String, Boolean], default: true },
    okDisabled: { type: [String, Boolean], default: false },
    okOnly: { type: [String, Boolean], default: false },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: [String, Boolean], default: false },
    show: { type: [String, Boolean], default: false },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: [String, Boolean], default: false },
    titleTag: { default: "h5" },
    autoFocusButton: { default: void 0 },
    teleportDisabled: { type: [String, Boolean], default: false },
    teleportTo: { default: "body" },
    bodyScrolling: { type: [String, Boolean], default: false }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = useSlots(), n = Ve(() => a.id, "modal"), s = ke(a, "modelValue", l), r = d(() => a.busy), u = d(() => a.lazy), f = d(() => a.cancelDisabled), v = d(() => a.centered), p = d(() => a.hideBackdrop), c = d(() => a.hideFooter), g = d(() => a.hideHeader), B = d(() => a.hideHeaderClose), m = d(s), V = d(() => a.noCloseOnBackdrop), b = d(() => a.noCloseOnEsc), T = d(() => a.noFade), _ = d(() => a.autoFocus), h2 = d(() => a.okDisabled), k = d(() => a.okOnly), C = d(() => a.scrollable), w = d(() => a.titleSrOnly), P = d(() => a.teleportDisabled), F = d(() => a.bodyScrolling), S = ref(null), I = ref(null), x = ref(null), z = ref(null), te = ref(m.value), Q = ref(false);
    sn(m, F);
    const { focused: G } = ze(S, {
      initialValue: m.value && a.autoFocusButton === void 0
    }), { focused: X } = ze(I, {
      initialValue: m.value && a.autoFocusButton === "ok"
    }), { focused: U } = ze(x, {
      initialValue: m.value && a.autoFocusButton === "cancel"
    }), { focused: pe } = ze(z, {
      initialValue: m.value && a.autoFocusButton === "close"
    }), be = computed(() => [
      a.modalClass,
      {
        fade: !T.value,
        show: te.value
      }
    ]), he = computed(
      () => u.value === false || u.value === true && Q.value === true || u.value === true && m.value === true
    ), ye = computed(() => !Fe(o["header-close"])), q = computed(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === true,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": v.value,
        "modal-dialog-scrollable": C.value
      }
    ]), ee = computed(() => [
      a.bodyClass,
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== null,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== null
      }
    ]), ne = computed(() => [
      a.headerClass,
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== null,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant !== null
      }
    ]), ue = computed(() => [
      a.footerClass,
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== null,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant !== null
      }
    ]), N = computed(() => [
      a.titleClass,
      {
        ["visually-hidden"]: w.value
      }
    ]), le = computed(() => f.value || r.value), de = computed(() => h2.value || r.value), Se = (L, me = {}) => new Mt(L, {
      cancelable: false,
      target: S.value || null,
      relatedTarget: null,
      trigger: null,
      ...me,
      componentId: n.value
    }), Ce = (L = "") => {
      const me = Se("hide", { cancelable: L !== "", trigger: L });
      if (L === "ok" && l(L, me), L === "cancel" && l(L, me), L === "close" && l(L, me), l("hide", me), me.defaultPrevented || L === "backdrop" && V.value || L === "esc" && b.value) {
        l("hide-prevented");
        return;
      }
      s.value = false;
    }, K = () => {
      const L = Se("show", { cancelable: true });
      if (l("show", L), L.defaultPrevented) {
        s.value = false, l("show-prevented");
        return;
      }
      s.value = true;
    }, ce = () => {
      _.value !== false && (a.autoFocusButton === "ok" ? X.value = true : a.autoFocusButton === "close" ? pe.value = true : a.autoFocusButton === "cancel" ? U.value = true : G.value = true);
    }, Le = () => K(), E = () => {
      te.value = true, ce(), l("shown", Se("shown")), u.value === true && (Q.value = true);
    }, W = () => {
      te.value = false;
    }, ge = () => {
      l("hidden", Se("hidden")), u.value === true && (Q.value = false);
    };
    return Zr(te), Te(S, "bv-toggle", () => {
      m.value ? Ce() : K();
    }), t({
      hide: Ce,
      show: K
    }), (L, me) => (openBlock(), createBlock(Teleport, {
      to: L.teleportTo,
      disabled: unref(P)
    }, [
      createVNode(Vt, {
        "no-fade": true,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: Le,
        onAfterEnter: E,
        onLeave: W,
        onAfterLeave: ge
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            id: unref(n),
            ref_key: "element",
            ref: S,
            class: ["modal", be.value],
            role: "dialog",
            "aria-labelledby": `${unref(n)}-label`,
            "aria-describedby": `${unref(n)}-body`,
            tabindex: "-1"
          }, L.$attrs, {
            onKeyup: me[5] || (me[5] = withKeys((ve) => Ce("esc"), ["esc"]))
          }), [
            createBaseVNode("div", {
              class: normalizeClass(["modal-dialog", q.value])
            }, [
              he.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["modal-content", L.contentClass])
              }, [
                unref(g) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["modal-header", ne.value])
                }, [
                  renderSlot(L.$slots, "header", {}, () => [
                    (openBlock(), createBlock(resolveDynamicComponent(L.titleTag), {
                      id: `${unref(n)}-label`,
                      class: normalizeClass(["modal-title", N.value])
                    }, {
                      default: withCtx(() => [
                        renderSlot(L.$slots, "title", {}, () => [
                          createTextVNode(toDisplayString(L.title), 1)
                        ], true)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    unref(B) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      ye.value ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        onClick: me[0] || (me[0] = (ve) => Ce("close"))
                      }, [
                        renderSlot(L.$slots, "header-close", {}, void 0, true)
                      ])) : (openBlock(), createBlock(Ot, {
                        key: 1,
                        ref_key: "closeButton",
                        ref: z,
                        "aria-label": L.headerCloseLabel,
                        white: L.headerCloseWhite,
                        onClick: me[1] || (me[1] = (ve) => Ce("close"))
                      }, null, 8, ["aria-label", "white"]))
                    ], 64))
                  ], true)
                ], 2)),
                createBaseVNode("div", {
                  id: `${unref(n)}-body`,
                  class: normalizeClass(["modal-body", ee.value])
                }, [
                  renderSlot(L.$slots, "default", {}, void 0, true)
                ], 10, Vd),
                unref(c) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(["modal-footer", ue.value])
                }, [
                  renderSlot(L.$slots, "footer", {}, () => [
                    renderSlot(L.$slots, "cancel", {}, () => [
                      unref(k) ? createCommentVNode("", true) : (openBlock(), createBlock(kt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: x,
                        disabled: le.value,
                        size: L.buttonSize,
                        variant: L.cancelVariant,
                        onClick: me[2] || (me[2] = (ve) => Ce("cancel"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(L.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], true),
                    renderSlot(L.$slots, "ok", {}, () => [
                      createVNode(kt, {
                        ref_key: "okButton",
                        ref: I,
                        disabled: de.value,
                        size: L.buttonSize,
                        variant: L.okVariant,
                        onClick: me[3] || (me[3] = (ve) => Ce("ok"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(L.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], true)
                  ], true)
                ], 2))
              ], 2)) : createCommentVNode("", true)
            ], 2),
            unref(p) ? createCommentVNode("", true) : renderSlot(L.$slots, "backdrop", { key: 0 }, () => [
              createBaseVNode("div", {
                class: "modal-backdrop fade show",
                onClick: me[4] || (me[4] = (ve) => Ce("backdrop"))
              })
            ], true)
          ], 16, Td), [
            [vShow, unref(m)]
          ])
        ]),
        _: 3
      })
    ], 8, ["to", "disabled"]));
  }
});
var Ad = ll(Od, [["__scopeId", "data-v-b5795927"]]);
var Pd = defineComponent({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: [String, Boolean], default: false },
    fill: { type: [String, Boolean], default: false },
    justified: { type: [String, Boolean], default: false },
    pills: { type: [String, Boolean], default: false },
    small: { type: [String, Boolean], default: false },
    tabs: { type: [String, Boolean], default: false },
    tag: { default: "ul" },
    vertical: { type: [String, Boolean], default: false },
    underline: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.cardHeader), a = d(() => t.fill), o = d(() => t.justified), n = d(() => t.pills), s = d(() => t.small), r = d(() => t.tabs), u = d(() => t.vertical), f = jt(() => t.align), v = d(() => t.underline), p = computed(() => ({
      "nav-tabs": r.value,
      "nav-pills": n.value && !r.value,
      "card-header-tabs": !u.value && l.value && r.value,
      "card-header-pills": !u.value && l.value && n.value && !r.value,
      "flex-column": u.value,
      "nav-fill": !u.value && a.value,
      "nav-justified": !u.value && o.value,
      [f.value]: !u.value && t.align !== void 0,
      small: s.value,
      "nav-underline": v.value
    }));
    return (c, g) => (openBlock(), createBlock(resolveDynamicComponent(c.tag), {
      class: normalizeClass(["nav", p.value])
    }, {
      default: withCtx(() => [
        renderSlot(c.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Ed = defineComponent({
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: false },
    novalidate: { type: [String, Boolean], default: false },
    validated: { type: [String, Boolean], default: false }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const l = e, a = computed(() => ({
      floating: l.floating,
      role: l.role,
      id: l.id,
      novalidate: l.novalidate,
      validated: l.validated
    })), o = (n) => t("submit", n);
    return (n, s) => (openBlock(), createBlock($n, mergeProps(a.value, {
      class: "d-flex",
      onSubmit: withModifiers(o, ["prevent"])
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
});
var Fd = { class: "nav-item" };
var Id = defineComponent({
  __name: "BNavItem",
  props: {
    linkClasses: { default: void 0 },
    linkAttrs: { default: void 0 },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: false },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.disabled), a = computed(
      () => Dt(t, {
        active: true,
        activeClass: true,
        append: true,
        disabled: true,
        href: true,
        icon: true,
        opacity: true,
        opacityHover: true,
        rel: true,
        replace: true,
        routerComponentName: true,
        target: true,
        to: true,
        underlineOffset: true,
        underlineOffsetHover: true,
        underlineOpacity: true,
        underlineOpacityHover: true,
        underlineVariant: true,
        variant: true
      })
    );
    return (o, n) => (openBlock(), createElementBlock("li", Fd, [
      createVNode(Qe, mergeProps({
        class: ["nav-link", o.linkClasses]
      }, { ...a.value, ...o.linkAttrs }, {
        "active-class": "active",
        tabindex: unref(l) ? -1 : void 0,
        "aria-disabled": unref(l) ? true : void 0
      }), {
        default: withCtx(() => [
          renderSlot(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "tabindex", "aria-disabled"])
    ]));
  }
});
var xd = { class: "nav-item dropdown" };
var Ld = defineComponent({
  __name: "BNavItemDropdown",
  props: {
    id: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    size: { default: "md" },
    offset: { default: void 0 },
    autoClose: { type: [Boolean, String], default: void 0 },
    dark: { type: [String, Boolean], default: void 0 },
    splitVariant: { default: void 0 },
    noCaret: { type: [String, Boolean], default: void 0 },
    variant: { default: "link" },
    modelValue: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: void 0 },
    strategy: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: void 0 },
    noShift: { type: [String, Boolean], default: void 0 },
    dropup: { type: [String, Boolean], default: void 0 },
    dropend: { type: [String, Boolean], default: void 0 },
    dropstart: { type: [String, Boolean], default: void 0 },
    center: { type: [String, Boolean], default: void 0 },
    end: { type: [String, Boolean], default: void 0 },
    menuClass: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = ke(a, "modelValue", l, { passive: true }), n = d(o), s = computed({
      get: () => n.value,
      set: (p) => {
        o.value = p;
      }
    }), r = computed(() => Fs(a, ["modelValue"]));
    return t({
      close: () => {
        o.value = false;
      },
      open: () => {
        o.value = true;
      },
      toggle: () => {
        o.value = !n.value;
      }
    }), (p, c) => (openBlock(), createElementBlock("li", xd, [
      createVNode(wn, mergeProps({
        modelValue: s.value,
        "onUpdate:modelValue": c[0] || (c[0] = (g) => s.value = g)
      }, r.value, { "is-nav": "" }), {
        "button-content": withCtx(() => [
          renderSlot(p.$slots, "button-content")
        ]),
        "toggle-text": withCtx(() => [
          renderSlot(p.$slots, "toggle-text")
        ]),
        default: withCtx(() => [
          renderSlot(p.$slots, "default")
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
});
var Nd = { class: "navbar-text" };
var zd = defineComponent({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (openBlock(), createElementBlock("li", Nd, [
      renderSlot(t.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(t.text), 1)
      ])
    ]));
  }
});
var Hd = defineComponent({
  __name: "BNavbar",
  props: {
    fixed: { default: void 0 },
    print: { type: [String, Boolean], default: false },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: false },
    dark: { type: [String, Boolean], default: false },
    variant: { default: null },
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, l = d(() => t.print), a = d(() => t.dark), o = computed(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), n = computed(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === false ? "navbar-expand" : void 0
    ), s = computed(
      () => t.container === true ? "container" : "container-fluid"
    ), r = computed(() => ({
      "d-print": l.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": a.value,
      [`bg-${t.variant}`]: t.variant !== null,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${n.value}`]: n.value !== void 0
    }));
    return provide(Ua, {
      tag: readonly(toRef(t, "tag"))
    }), (u, f) => (openBlock(), createBlock(resolveDynamicComponent(u.tag), {
      class: normalizeClass(["navbar", r.value]),
      role: o.value
    }, {
      default: withCtx(() => [
        u.container !== false ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(s.value)
        }, [
          renderSlot(u.$slots, "default")
        ], 2)) : renderSlot(u.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
});
var Rd = defineComponent({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: false },
    disabled: { type: [String, Boolean], default: false },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: false },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = computed(() => St(t)), a = computed(() => l.value ? Qe : t.tag), o = computed(
      () => l.value ? Dt(t, {
        active: true,
        activeClass: true,
        append: true,
        disabled: true,
        href: true,
        rel: true,
        replace: true,
        routerComponentName: true,
        target: true,
        to: true,
        variant: true,
        opacity: true,
        opacityHover: true,
        underlineVariant: true,
        underlineOffset: true,
        underlineOffsetHover: true,
        underlineOpacity: true,
        underlineOpacityHover: true,
        icon: true
      }) : {}
    );
    return (n, s) => (openBlock(), createBlock(resolveDynamicComponent(a.value), mergeProps({ class: "navbar-brand" }, o.value), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Md = defineComponent({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: [String, Boolean], default: false },
    justified: { type: [String, Boolean], default: false },
    small: { type: [String, Boolean], default: false },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, l = d(() => t.fill), a = d(() => t.justified), o = d(() => t.small), n = jt(() => t.align), s = computed(() => ({
      "nav-fill": l.value,
      "nav-justified": a.value,
      [n.value]: t.align !== void 0,
      small: o.value
    }));
    return (r, u) => (openBlock(), createElementBlock("ul", {
      class: normalizeClass(["navbar-nav", s.value])
    }, [
      renderSlot(r.$slots, "default")
    ], 2));
  }
});
var eo = (e, t) => e.setAttribute("data-bs-theme", t);
var Dd = {
  mounted(e, t) {
    eo(e, t.value);
  },
  updated(e, t) {
    eo(e, t.value);
  }
};
var sl = (e, t) => {
  const { modifiers: l, arg: a, value: o } = e, n = Object.keys(l || {}), s = typeof o == "string" ? o.split(Yt) : o;
  if (As(t.tagName, "a")) {
    const r = Ga(t, "href") || "";
    ns.test(r) && n.push(r.replace(os, ""));
  }
  return Array.prototype.concat.apply([], [a, s]).forEach((r) => typeof r == "string" && n.push(r)), n.filter((r, u, f) => r && f.indexOf(r) === u);
};
var jd = (e, t) => {
  sl(e, t).forEach((a) => {
    const o = document.getElementById(a);
    o !== null && o.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => xn(e, t), 50);
};
var xn = (e, t) => {
  const l = sl(e, t);
  let a = false;
  l.forEach((o) => {
    const n = document.getElementById(o);
    n != null && n.classList.contains("show") && (a = true), n != null && n.classList.contains("closing") && (a = false);
  }), t.setAttribute("aria-expanded", a ? "true" : "false");
};
var Na = {
  mounted(e, t) {
    e.__toggle = () => jd(t, e), e.addEventListener("click", e.__toggle), xn(t, e), e.setAttribute("aria-controls", sl(t, e).join(" "));
  },
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
};
var qd = {
  mounted(e, t) {
    if (!Ht(t.value))
      return;
    const a = sa(t.value, e);
    !a.content && !a.title || (e.$__state = ref({
      ...ra(t, e),
      ...a
    }), rn(e, t));
  },
  updated(e, t) {
    if (!Ht(t.value))
      return;
    const a = sa(t.value, e);
    !a.content && !a.title || e.$__state && (e.$__state.value = {
      ...ra(t, e),
      ...a
    });
  },
  beforeUnmount(e) {
    un(e);
  }
};
var Gd = {
  mounted(e, t) {
    const l = Ht(t.value);
    if (!l)
      return;
    const a = sa(t.value, e);
    !a.content && !a.title || (e.$__state = ref({
      ...ra(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: l
    }), rn(e, t));
  },
  updated(e, t) {
    const l = Ht(t.value);
    if (!l)
      return;
    const a = sa(t.value, e);
    !a.content && !a.title || e.$__state && (e.$__state.value = {
      ...ra(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: l
    });
  },
  beforeUnmount(e) {
    un(e);
  }
};
var to = Object.freeze(Object.defineProperty({
  __proto__: null,
  vBColorMode: Dd,
  vBModal: Na,
  vBPopover: qd,
  vBToggle: Na,
  vBTooltip: Gd
}, Symbol.toStringTag, { value: "Module" }));
var Wd = createBaseVNode("span", { class: "navbar-toggler-icon" }, null, -1);
var Ud = defineComponent({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: [String, Boolean], default: false },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.disabled), o = computed(() => ({
      disabled: a.value,
      "aria-label": l.label
    })), n = computed(() => ({
      disabled: a.value
    })), s = (r) => {
      a.value || t("click", r);
    };
    return (r, u) => withDirectives((openBlock(), createElementBlock("button", mergeProps({
      class: ["navbar-toggler", n.value],
      type: "button"
    }, o.value, { onClick: s }), [
      renderSlot(r.$slots, "default", {}, () => [
        Wd
      ])
    ], 16)), [
      [unref(Na), unref(a) ? void 0 : r.target]
    ]);
  }
});
var Ln = defineComponent({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: [String, Boolean], default: false },
    noCenter: { type: [String, Boolean], default: false },
    noFade: { type: [String, Boolean], default: false },
    noWrap: { type: [String, Boolean], default: false },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: false },
    show: { type: [String, Boolean], default: false },
    spinnerSmall: { type: [String, Boolean], default: false },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    noSpinner: { type: [String, Boolean], default: false },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const l = e, a = { top: 0, left: 0, bottom: 0, right: 0 }, o = d(() => l.fixed), n = d(() => l.noSpinner), s = d(() => l.noCenter), r = d(() => l.noWrap), u = d(() => l.show), f = d(() => l.spinnerSmall), v = computed(
      () => l.rounded === true || l.rounded === "" ? "rounded" : l.rounded === false ? "" : `rounded-${l.rounded}`
    ), p = computed(
      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : ""
    ), c = computed(() => u.value ? true : null), g = computed(() => ({
      type: l.spinnerType,
      variant: l.spinnerVariant,
      small: f.value
    })), B = computed(() => ({
      ...a,
      zIndex: l.zIndex || 10
    })), m = computed(() => [
      "b-overlay",
      {
        "position-absolute": !r.value || !o.value,
        "position-fixed": r.value && o.value
      }
    ]), V = computed(() => [p.value, v.value]), b = computed(() => ({
      ...a,
      opacity: l.opacity,
      backgroundColor: l.bgColor || void 0,
      backdropFilter: l.blur ? `blur(${l.blur})` : void 0
    })), T = computed(
      () => s.value ? a : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (_, h2) => (openBlock(), createBlock(resolveDynamicComponent(_.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": c.value
    }, {
      default: withCtx(() => [
        renderSlot(_.$slots, "default"),
        createVNode(Vt, {
          "no-fade": _.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: h2[1] || (h2[1] = (k) => t("shown")),
          onOnAfterLeave: h2[2] || (h2[2] = (k) => t("hidden"))
        }, {
          default: withCtx(() => [
            unref(u) ? (openBlock(), createBlock(resolveDynamicComponent(_.overlayTag), {
              key: 0,
              class: normalizeClass(m.value),
              style: normalizeStyle(B.value),
              onClick: h2[0] || (h2[0] = (k) => t("click", k))
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass(["position-absolute", V.value]),
                  style: normalizeStyle(b.value)
                }, null, 6),
                createBaseVNode("div", {
                  class: "position-absolute",
                  style: normalizeStyle(T.value)
                }, [
                  renderSlot(_.$slots, "overlay", normalizeProps(guardReactiveProps(g.value)), () => [
                    unref(n) ? createCommentVNode("", true) : (openBlock(), createBlock(ma, normalizeProps(mergeProps({ key: 0 }, g.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
});
var Kd = ["id", "aria-labelledby"];
var Xd = ["id"];
var Yd = defineComponent({
  inheritAttrs: false,
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { type: [String, Boolean], default: false },
    bodyScrolling: { type: [String, Boolean], default: false },
    backdrop: { type: [String, Boolean], default: true },
    noCloseOnBackdrop: { type: [String, Boolean], default: false },
    noCloseOnEsc: { type: [String, Boolean], default: false },
    placement: { default: "start" },
    title: { default: void 0 },
    noHeaderClose: { type: [String, Boolean], default: false },
    noHeader: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: false },
    id: { default: void 0 },
    noFocus: { type: [String, Boolean], default: false },
    backdropVariant: { default: "dark" },
    headerClass: { default: void 0 },
    bodyClass: { default: void 0 },
    footerClass: { default: void 0 },
    teleportDisabled: { type: [String, Boolean], default: false },
    teleportTo: { default: "body" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = useSlots(), n = ke(a, "modelValue", l, { passive: true }), s = d(n), r = d(() => a.bodyScrolling), u = d(() => a.backdrop), f = d(() => a.noHeaderClose), v = d(() => a.noHeader), p = d(() => a.noFocus), c = d(() => a.noCloseOnBackdrop), g = d(() => a.noCloseOnEsc), B = d(() => a.lazy), m = d(() => a.teleportDisabled), V = Ve(() => a.id, "offcanvas");
    sn(s, r);
    const b = ref(null), { focused: T } = ze(b, {
      initialValue: s.value && p.value === false
    }), _ = ref(s.value), h2 = ref(false), k = computed(
      () => u.value === true && s.value === true
    ), C = computed(
      () => B.value === false || B.value === true && h2.value === true || B.value === true && s.value === true
    ), w = computed(() => !Fe(o.footer)), P = computed(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: s.value && _.value === true
      }
    ]), F = (X, U = {}) => new Mt(X, {
      cancelable: false,
      target: b.value || null,
      relatedTarget: null,
      trigger: null,
      ...U,
      componentId: V.value
    }), S = (X = "") => {
      const U = F("hide", { cancelable: X !== "", trigger: X });
      if (X === "close" && l(X, U), X === "esc" && l(X, U), l("hide", U), U.defaultPrevented || X === "backdrop" && c.value || X === "esc" && g.value) {
        l("hide-prevented");
        return;
      }
      n.value = false;
    }, I = () => {
      const X = F("show", { cancelable: true });
      if (l("show", X), X.defaultPrevented) {
        n.value = false, l("show-prevented");
        return;
      }
      n.value = true;
    }, x = () => {
      nextTick(() => {
        p.value === false && (T.value = true);
      });
    }, z = () => I(), te = () => {
      _.value = true, x(), l("shown", F("shown")), B.value === true && (h2.value = true);
    }, Q = () => {
      _.value = false;
    }, G = () => {
      l("hidden", F("hidden")), B.value === true && (h2.value = false);
    };
    return Te(b, "bv-toggle", () => {
      s.value ? S() : I();
    }), t({
      hide: S,
      show: I
    }), (X, U) => (openBlock(), createBlock(Teleport, {
      to: X.teleportTo,
      disabled: unref(m)
    }, [
      createVNode(Vt, {
        "no-fade": true,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: z,
        onAfterEnter: te,
        onLeave: Q,
        onAfterLeave: G
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            id: unref(V),
            ref_key: "element",
            ref: b,
            "aria-modal": "true",
            role: "dialog",
            class: P.value,
            tabindex: "-1",
            "aria-labelledby": `${unref(V)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, X.$attrs, {
            onKeyup: U[1] || (U[1] = withKeys((pe) => S("esc"), ["esc"]))
          }), [
            C.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              unref(v) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["offcanvas-header", X.headerClass])
              }, [
                renderSlot(X.$slots, "header", normalizeProps(guardReactiveProps({ visible: unref(s), placement: X.placement, hide: S })), () => [
                  createBaseVNode("h5", {
                    id: `${unref(V)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    renderSlot(X.$slots, "title", {}, () => [
                      createTextVNode(toDisplayString(X.title), 1)
                    ])
                  ], 8, Xd),
                  unref(f) ? createCommentVNode("", true) : (openBlock(), createBlock(Ot, {
                    key: 0,
                    class: "text-reset",
                    "aria-label": X.dismissLabel,
                    onClick: U[0] || (U[0] = (pe) => S("close"))
                  }, null, 8, ["aria-label"]))
                ])
              ], 2)),
              createBaseVNode("div", {
                class: normalizeClass(["offcanvas-body", X.bodyClass])
              }, [
                renderSlot(X.$slots, "default")
              ], 2),
              w.value ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(X.footerClass)
              }, [
                renderSlot(X.$slots, "footer", normalizeProps(guardReactiveProps({ visible: unref(s), placement: X.placement, hide: S })))
              ], 2)) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true)
          ], 16, Kd), [
            [vShow, unref(n)]
          ])
        ]),
        _: 3
      }),
      createVNode(Ln, {
        variant: X.backdropVariant,
        show: k.value,
        fixed: true,
        "no-wrap": "",
        "no-spinner": true,
        onClick: U[2] || (U[2] = (pe) => S("backdrop"))
      }, null, 8, ["variant", "show"])
    ], 8, ["to", "disabled"]));
  }
});
var Jd = 5;
var Nn = 20;
var zn = 0;
var Xe = 3;
var Zd = "ellipsis-text";
var Qd = "first-text";
var ec = "last-text";
var tc = "next-text";
var ac = "page";
var lc = "prev-text";
var ao = (e) => Math.max(ot(e) || Nn, 1);
var lo = (e) => Math.max(ot(e) || zn, 0);
var oc = (e, t) => {
  const l = ot(e) || 1;
  return l > t ? t : l < 1 ? 1 : l;
};
var nc = defineComponent({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: false },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "â¦" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: false },
    firstText: { type: String, default: "Â«" },
    hideEllipsis: { type: [Boolean, String], default: false },
    hideGotoEndButtons: { type: [Boolean, String], default: false },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: false },
    lastText: { type: String, default: "Â»" },
    limit: { type: Number, default: Jd },
    modelValue: { type: Number, default: 1 },
    // V-model prop
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "âº" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: Nn },
    pills: { type: [Boolean, String], default: false },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "â¹" },
    size: { type: String, default: "md" },
    totalRows: { type: Number, default: zn }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: l }) {
    const a = ke(e, "modelValue", t), o = d(() => e.disabled), n = d(() => e.firstNumber), s = d(() => e.hideEllipsis), r = d(() => e.hideGotoEndButtons), u = d(() => e.lastNumber), f = d(() => e.pills), v = computed(
      () => e.align === "fill" ? "start" : e.align
    ), p = jt(v), c = computed(
      () => Math.ceil(lo(e.totalRows) / ao(e.perPage))
    ), g = computed(() => {
      let C;
      return c.value - a.value + 2 < e.limit && e.limit > Xe ? C = c.value - m.value + 1 : C = a.value - Math.floor(m.value / 2), C < 1 ? C = 1 : C > c.value - m.value && (C = c.value - m.value + 1), e.limit <= Xe && u.value && c.value === C + m.value - 1 && (C = Math.max(C - 1, 1)), C;
    }), B = computed(() => {
      const C = c.value - a.value;
      let w = false;
      return C + 2 < e.limit && e.limit > Xe ? e.limit > Xe && (w = true) : e.limit > Xe && (w = !!(!s.value || n.value)), g.value <= 1 && (w = false), w && n.value && g.value < 4 && (w = false), w;
    }), m = computed(() => {
      let C = e.limit;
      return c.value <= e.limit ? C = c.value : a.value < e.limit - 1 && e.limit > Xe ? ((!s.value || u.value) && (C = e.limit - (n.value ? 0 : 1)), C = Math.min(C, e.limit)) : c.value - a.value + 2 < e.limit && e.limit > Xe ? (!s.value || n.value) && (C = e.limit - (u.value ? 0 : 1)) : e.limit > Xe && (C = e.limit - (s.value ? 0 : 2)), C;
    }), V = computed(() => {
      const C = c.value - m.value;
      let w = false;
      a.value < e.limit - 1 && e.limit > Xe ? (!s.value || u.value) && (w = true) : e.limit > Xe && (w = !!(!s.value || u.value)), g.value > C && (w = false);
      const P = g.value + m.value - 1;
      return w && u.value && P > c.value - 3 && (w = false), w;
    }), b = reactive({
      pageSize: ao(e.perPage),
      totalRows: lo(e.totalRows),
      numberOfPages: c.value
    }), T = (C, w) => {
      if (w === a.value)
        return;
      const { target: P } = C, F = new Je("page-click", {
        cancelable: true,
        target: P
      });
      t("page-click", F, w), !F.defaultPrevented && (a.value = w);
    }, _ = computed(() => e.size ? `pagination-${e.size}` : ""), h2 = computed(() => f.value ? "b-pagination-pills" : "");
    watch(a, (C) => {
      const w = oc(C, c.value);
      w !== a.value && (a.value = w);
    }), watch(b, (C, w) => {
      C != null && (w.pageSize !== C.pageSize && w.totalRows === C.totalRows || w.numberOfPages !== C.numberOfPages && a.value > w.numberOfPages) && (a.value = 1);
    });
    const k = computed(() => {
      const C = [];
      for (let w = 0; w < m.value; w++)
        C.push({ number: g.value + w, classes: null });
      return C;
    });
    return () => {
      const C = [], w = k.value.map((G) => G.number), P = (G) => G === a.value, F = a.value < 1, S = e.align === "fill", I = (G, X, U, pe, be, he) => {
        const ye = o.value || P(he) || F || G < 1 || G > c.value, q = G < 1 ? 1 : G > c.value ? c.value : G, ee = { disabled: ye, page: q, index: q - 1 }, ne = Me(U, ee, l) || pe || "";
        return h(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: ye,
                "flex-fill": S,
                "d-flex": S && !ye
              },
              be
            ]
          },
          // render inner content
          h(
            ye ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !ye && S }],
              "aria-label": X,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": ye ? true : null,
              role: "menuitem",
              type: ye ? null : "button",
              tabindex: ye ? null : "-1",
              onClick: (ue) => {
                ye || T(ue, q);
              }
            },
            ne
          )
        );
      }, x = (G) => h(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            S ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${G ? "last" : "first"}`
        },
        [
          h(
            "span",
            { class: ["page-link"] },
            Me(Zd, {}, l) || e.ellipsisText || "..."
          )
        ]
      ), z = (G, X) => {
        const U = P(G.number) && !F, pe = o.value ? null : U || F && X === 0 ? "0" : "-1", be = {
          active: U,
          disabled: o.value,
          page: G.number,
          index: G.number - 1,
          content: G.number
        }, he = Me(ac, be, l) || G.number, ye = h(
          o.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !o.value && S }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": o.value ? true : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${G.number}` : null,
            role: "menuitemradio",
            type: o.value ? null : "button",
            tabindex: pe,
            onClick: (q) => {
              o.value || T(q, G.number);
            }
          },
          he
        );
        return h(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: o.value,
                active: U,
                "flex-fill": S,
                "d-flex": S && !o.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${G.number}`
          },
          ye
        );
      };
      if (!r.value && !n.value) {
        const G = I(
          1,
          e.labelFirstPage,
          Qd,
          e.firstText,
          e.firstClass,
          1
        );
        C.push(G);
      }
      const te = I(
        a.value - 1,
        e.labelFirstPage,
        lc,
        e.prevText,
        e.prevClass,
        1
      );
      C.push(te), n.value && w[0] !== 1 && C.push(z({ number: 1 }, 0)), B.value && C.push(x(false)), k.value.forEach((G, X) => {
        const U = B.value && n.value && w[0] !== 1 ? 1 : 0;
        C.push(z(G, X + U));
      }), V.value && C.push(x(true)), u.value && w[w.length - 1] !== c.value && C.push(z({ number: c.value }, -1));
      const Q = I(
        a.value + 1,
        e.labelNextPage,
        tc,
        e.nextText,
        e.nextClass,
        c.value
      );
      if (C.push(Q), !u.value && !r.value) {
        const G = I(
          c.value,
          e.labelLastPage,
          ec,
          e.lastText,
          e.lastClass,
          c.value
        );
        C.push(G);
      }
      return h(
        "ul",
        {
          class: ["pagination", _.value, p.value, h2.value],
          role: "menubar",
          "aria-disabled": o.value,
          "aria-label": e.ariaLabel || null
        },
        C
      );
    };
  }
});
var Re = defineComponent({
  inheritAttrs: false,
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    wrapperTag: { default: "span" },
    width: { default: void 0 },
    cols: { default: 12 },
    variant: { default: null },
    size: { default: "md" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, l = computed(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), a = computed(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), o = computed(() => ({
      [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,
      [`bg-${t.variant}`]: t.variant !== null,
      [`placeholder-${t.size}`]: t.size !== "md"
    })), n = computed(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), s = computed(() => ({
      width: l.value === void 0 ? void 0 : `${l.value}%`
    }));
    return (r, u) => (openBlock(), createBlock(resolveDynamicComponent(r.wrapperTag), {
      class: normalizeClass(n.value)
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(r.tag), mergeProps(r.$attrs, {
          class: ["placeholder", o.value],
          style: s.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
});
var Hn = defineComponent({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: { default: void 0 },
    cols: { default: void 0 },
    variant: { default: "primary" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`btn-${t.variant}`]: t.variant !== null
    })), a = computed(() => ({
      animation: t.animation,
      width: t.width,
      cols: t.cols,
      tag: t.tag
    }));
    return (o, n) => (openBlock(), createBlock(Re, mergeProps({
      class: ["btn disabled", l.value]
    }, a.value), null, 16, ["class"]));
  }
});
var sc = defineComponent({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { type: [String, Boolean], default: false },
    headerWidth: { default: 100 },
    headerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    noFooter: { type: [String, Boolean], default: false },
    footerWidth: { default: 100 },
    footerVariant: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    animation: { default: void 0 },
    size: { default: "md" },
    variant: { default: void 0 },
    noButton: { type: [String, Boolean], default: false },
    imgBottom: { type: [String, Boolean], default: false },
    imgSrc: { default: void 0 },
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.noButton), a = d(() => t.noHeader), o = d(() => t.noFooter), n = d(() => t.noImg), s = computed(() => ({
      width: t.headerWidth,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      size: t.headerSize
    })), r = computed(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: l.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), u = computed(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    })), f = computed(() => ({
      blank: !t.imgSrc,
      blankColor: t.imgBlankColor,
      height: t.imgSrc ? void 0 : t.imgHeight,
      src: t.imgSrc,
      top: !t.imgBottom,
      bottom: t.imgBottom
    }));
    return (v, p) => (openBlock(), createBlock(bn, { "img-bottom": v.imgBottom }, createSlots({
      default: withCtx(() => [
        renderSlot(v.$slots, "default", {}, () => [
          createVNode(Re, mergeProps({ cols: "7" }, u.value), null, 16),
          createVNode(Re, mergeProps({ cols: "4" }, u.value), null, 16),
          createVNode(Re, mergeProps({ cols: "4" }, u.value), null, 16),
          createVNode(Re, mergeProps({ cols: "6" }, u.value), null, 16),
          createVNode(Re, mergeProps({ cols: "8" }, u.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      unref(n) ? void 0 : {
        name: "img",
        fn: withCtx(() => [
          renderSlot(v.$slots, "img", {}, () => [
            createVNode(ia, normalizeProps(guardReactiveProps(f.value)), null, 16)
          ])
        ]),
        key: "0"
      },
      unref(a) ? void 0 : {
        name: "header",
        fn: withCtx(() => [
          renderSlot(v.$slots, "header", {}, () => [
            createVNode(Re, normalizeProps(guardReactiveProps(s.value)), null, 16)
          ])
        ]),
        key: "1"
      },
      unref(o) ? void 0 : {
        name: "footer",
        fn: withCtx(() => [
          renderSlot(v.$slots, "footer", {}, () => [
            unref(l) ? (openBlock(), createBlock(Re, normalizeProps(mergeProps({ key: 1 }, r.value)), null, 16)) : (openBlock(), createBlock(Hn, normalizeProps(mergeProps({ key: 0 }, r.value)), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
});
var rl = defineComponent({
  __name: "BTableSimple",
  props: {
    bordered: { type: [String, Boolean], default: false },
    borderless: { type: [String, Boolean], default: false },
    borderVariant: { default: null },
    captionTop: { type: [String, Boolean], default: false },
    dark: { type: [String, Boolean], default: false },
    hover: { type: [String, Boolean], default: false },
    responsive: { type: [Boolean, String], default: false },
    stacked: { type: [Boolean, String], default: false },
    striped: { type: [String, Boolean], default: false },
    small: { type: [String, Boolean], default: false },
    tableClass: { default: void 0 },
    tableVariant: { default: null },
    stickyHeader: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.captionTop), a = d(() => t.borderless), o = d(() => t.bordered), n = d(() => t.dark), s = d(() => t.hover), r = d(() => t.small), u = d(() => t.striped), f = d(() => t.stickyHeader), v = computed(() => [
      "table",
      "b-table",
      {
        "table-bordered": o.value,
        "table-borderless": a.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== null,
        "caption-top": l.value,
        "table-dark": n.value,
        "table-hover": s.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": u.value,
        "table-sm": r.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== null
      },
      t.tableClass
    ]), p = computed(() => [
      {
        "table-responsive": t.responsive === true,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": f.value
      }
    ]);
    return (c, g) => c.responsive ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(p.value)
    }, [
      createBaseVNode("table", {
        class: normalizeClass(v.value)
      }, [
        renderSlot(c.$slots, "default")
      ], 2)
    ], 2)) : (openBlock(), createElementBlock("table", {
      key: 0,
      class: normalizeClass(v.value)
    }, [
      renderSlot(c.$slots, "default")
    ], 2));
  }
});
var rc = defineComponent({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: { default: "md" },
    animation: { default: void 0 },
    variant: { default: void 0 },
    headerColumns: { default: void 0 },
    hideHeader: { type: [String, Boolean], default: false },
    headerCellWidth: { default: 100 },
    headerSize: { default: "md" },
    headerAnimation: { default: void 0 },
    headerVariant: { default: void 0 },
    footerColumns: { default: void 0 },
    showFooter: { type: [String, Boolean], default: false },
    footerCellWidth: { default: 100 },
    footerSize: { default: "md" },
    footerAnimation: { default: void 0 },
    footerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, l = bt(() => t.columns, { nanToZero: true, method: "parseInt" }), a = bt(() => t.rows, { nanToZero: true, method: "parseInt" }), o = computed(() => t.headerColumns ?? NaN), n = computed(() => t.footerColumns ?? NaN), s = bt(o, {
      nanToZero: true,
      method: "parseInt"
    }), r = bt(n, {
      nanToZero: true,
      method: "parseInt"
    }), u = computed(() => l.value || 5), f = computed(() => a.value || 3), v = computed(
      () => t.headerColumns === void 0 ? u.value : s.value
    ), p = computed(
      () => t.footerColumns === void 0 ? u.value : r.value
    ), c = computed(() => ({
      size: t.size,
      variant: t.variant,
      animation: t.animation,
      width: t.cellWidth
    })), g = computed(() => ({
      size: t.headerSize,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      width: t.headerCellWidth
    })), B = computed(() => ({
      size: t.footerSize,
      variant: t.footerVariant,
      animation: t.footerAnimation,
      width: t.footerCellWidth
    })), m = d(() => t.hideHeader), V = d(() => t.showFooter);
    return (b, T) => (openBlock(), createBlock(rl, null, {
      default: withCtx(() => [
        unref(m) ? createCommentVNode("", true) : renderSlot(b.$slots, "thead", { key: 0 }, () => [
          createBaseVNode("thead", null, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(v.value, (_, h2) => (openBlock(), createElementBlock("th", { key: h2 }, [
                createVNode(Re, normalizeProps(guardReactiveProps(g.value)), null, 16)
              ]))), 128))
            ])
          ])
        ]),
        renderSlot(b.$slots, "default", {}, () => [
          createBaseVNode("tbody", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(f.value, (_, h2) => (openBlock(), createElementBlock("tr", { key: h2 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(u.value, (k, C) => (openBlock(), createElementBlock("td", { key: C }, [
                createVNode(Re, normalizeProps(guardReactiveProps(c.value)), null, 16)
              ]))), 128))
            ]))), 128))
          ])
        ]),
        unref(V) ? renderSlot(b.$slots, "tfoot", { key: 1 }, () => [
          createBaseVNode("tfoot", null, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(p.value, (_, h2) => (openBlock(), createElementBlock("th", { key: h2 }, [
                createVNode(Re, normalizeProps(guardReactiveProps(B.value)), null, 16)
              ]))), 128))
            ])
          ])
        ]) : createCommentVNode("", true)
      ]),
      _: 3
    }));
  }
});
var ic = defineComponent({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: [String, Boolean], default: false }
  },
  setup(e) {
    const t = e, l = d(() => t.loading);
    return (a, o) => unref(l) ? renderSlot(a.$slots, "loading", { key: 0 }) : renderSlot(a.$slots, "default", { key: 1 });
  }
});
var uc = ["aria-valuenow", "aria-valuemax"];
var Rn = defineComponent({
  __name: "BProgressBar",
  props: {
    animated: { type: [String, Boolean], default: false },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: false },
    showValue: { type: [String, Boolean], default: false },
    striped: { type: [String, Boolean], default: false },
    value: { default: 0 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = inject($o, null), a = d(() => t.animated), o = d(() => t.showProgress), n = d(() => t.showValue), s = d(() => t.striped), r = computed(() => ({
      "progress-bar-animated": a.value || (l == null ? void 0 : l.animated.value),
      "progress-bar-striped": s.value || (l == null ? void 0 : l.striped.value) || a.value || (l == null ? void 0 : l.animated.value),
      [`bg-${t.variant}`]: t.variant !== null
    })), u = computed(
      () => typeof t.precision == "number" ? t.precision : Number.parseFloat(t.precision)
    ), f = computed(
      () => typeof t.value == "number" ? t.value : Number.parseFloat(t.value)
    ), v = computed(
      () => typeof t.max == "number" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)
    ), p = computed(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || l != null && l.showValue.value ? f.value.toFixed(u.value) : o.value || l != null && l.showProgress.value ? (f.value * 100 / (v.value || 100)).toFixed(u.value) : t.label !== void 0 ? t.label : ""
    ), c = computed(
      () => l != null && l.max.value ? `${f.value * 100 / (typeof l.max.value == "number" ? l.max.value : Number.parseInt(l.max.value))}%` : t.max ? `${f.value * 100 / (typeof t.max == "number" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (g, B) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["progress-bar", r.value]),
      role: "progressbar",
      "aria-valuenow": g.value,
      "aria-valuemin": "0",
      "aria-valuemax": g.max,
      style: normalizeStyle({ width: c.value })
    }, [
      renderSlot(g.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(p.value), 1)
      ])
    ], 14, uc));
  }
});
var dc = defineComponent({
  __name: "BProgress",
  props: {
    variant: { default: void 0 },
    max: { default: 100 },
    height: { default: void 0 },
    animated: { type: [String, Boolean], default: false },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: false },
    showValue: { type: [String, Boolean], default: false },
    striped: { type: [String, Boolean], default: false },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, l = d(() => t.animated), a = d(() => t.showProgress), o = d(() => t.showValue), n = d(() => t.striped), s = computed(() => ({
      animated: t.animated,
      max: t.max,
      precision: t.precision,
      showProgress: t.showProgress,
      showValue: t.showValue,
      striped: t.striped,
      value: t.value,
      variant: t.variant
    }));
    return provide($o, {
      animated: l,
      max: readonly(toRef(t, "max")),
      showProgress: a,
      showValue: o,
      striped: n
    }), (r, u) => (openBlock(), createElementBlock("div", {
      class: "progress",
      style: normalizeStyle({ height: r.height })
    }, [
      renderSlot(r.$slots, "default", {}, () => [
        createVNode(Rn, normalizeProps(guardReactiveProps(s.value)), null, 16)
      ])
    ], 4));
  }
});
var oo = ca("cols", [""], { type: [String, Number], default: null });
var cc = defineComponent({
  name: "BRow",
  slots: Object,
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: false },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...oo
  },
  setup(e) {
    const t = d(() => e.noGutters), l = jt(() => e.alignH), a = computed(() => So(e, oo, "cols", "row-cols"));
    return {
      computedClasses: computed(() => [
        a.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [l.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function fc(e, t, l, a, o, n) {
  return openBlock(), createBlock(resolveDynamicComponent(e.tag), {
    class: normalizeClass(["row", e.computedClasses])
  }, {
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
var vc = ll(cc, [["render", fc]]);
var pc = ["TD", "TH", "TR"];
var mc = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(",");
var Xt = (e) => {
  if (!e || !e.target)
    return false;
  const t = e.target;
  if ("disabled" in t && t.disabled || pc.indexOf(t.tagName) !== -1)
    return false;
  if (fl(".dropdown-menu", t))
    return true;
  const l = t.tagName === "LABEL" ? t : fl("label", t);
  if (l) {
    const a = Ga(l, "for"), o = a ? Ts(a) : ho("input, select, textarea", l);
    if (o && !o.disabled)
      return true;
  }
  return Bo(t, mc);
};
var gc = () => {
  const e = (f, v) => {
    const p = [];
    return !(f != null && f.length) && (v != null && v.length) ? (Object.keys(v[0]).forEach((c) => p.push({ key: c, label: il(c) })), p) : (Array.isArray(f) && f.forEach((c) => {
      typeof c == "string" ? p.push({ key: c, label: il(c) }) : Sa(c) && c.key && typeof c.key == "string" && p.push({ ...c });
    }), p);
  }, t = ref([]), l = (f, v, p, c) => (t.value = ea(v), "isFilterableTable" in c && c.isFilterableTable.value === true && p.filter && (t.value = n(t.value, p.filter, p.filterable)), "isSortable" in c && c.isSortable.value === true && (t.value = o(
    f,
    t.value,
    {
      key: p.sortBy,
      desc: c.sortDescBoolean.value
    },
    p.sortCompare
  )), t.value), a = ref(void 0), o = (f, v, p, c) => {
    if (!p || !p.key)
      return v;
    const g = p.key;
    return v.sort((B, m) => {
      if (c !== void 0)
        return c(B, m, p.key, p.desc);
      const V = (_) => typeof _ == "object" ? JSON.stringify(_) : _;
      return V(B[g]) > V(m[g]) ? p.desc ? -1 : 1 : V(m[g]) > V(B[g]) ? p.desc ? 1 : -1 : 0;
    });
  }, n = (f, v, p) => f.filter(
    (c) => Object.entries(c).filter((g) => {
      const [B, m] = g;
      return !m || B[0] === "_" || p.length > 0 && !p.includes(B) ? false : (typeof m == "object" ? JSON.stringify(Object.values(m)) : typeof m == "string" ? m : m.toString()).toLowerCase().includes(v.toLowerCase());
    }).length > 0
  );
  return {
    normaliseFields: e,
    mapItems: l,
    internalItems: t,
    updateInternalItems: async (f) => {
      try {
        return t.value = await wa(f), t.value;
      } catch {
        return;
      }
    },
    filterEvent: a,
    notifyFilteredItems: () => {
      a.value && a.value(t.value);
    },
    formatItem: (f, v) => {
      const p = f[v.key];
      return v.formatter && typeof v.formatter == "function" ? v.formatter(p, v.key, f) : f[v.key];
    }
  };
};
var yc = ["title", "abbr", "onClick"];
var bc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" };
var hc = { key: 1 };
var Bc = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"];
var Sc = {
  key: 0,
  class: "b-table-stacked-label"
};
var _c = ["colspan"];
var wc = ["colspan"];
var $c = { class: "d-flex align-items-center justify-content-center gap-2" };
var kc = createBaseVNode("strong", null, "Loading...", -1);
var Cc = {
  key: 1,
  class: "b-table-empty-slot"
};
var Tc = ["colspan"];
var Vc = { key: 0 };
var Oc = ["title", "abbr", "onClick"];
var Ac = { key: 1 };
var Pc = { key: 2 };
var Ec = { key: 3 };
var Fc = defineComponent({
  __name: "BTable",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionTop: { type: [String, Boolean], default: false },
    borderless: { type: [String, Boolean], default: false },
    bordered: { type: [String, Boolean], default: false },
    borderVariant: { default: void 0 },
    dark: { type: [String, Boolean], default: false },
    fields: { default: () => [] },
    footClone: { type: [String, Boolean], default: false },
    hover: { type: [String, Boolean], default: false },
    items: { default: () => [] },
    provider: { type: Function, default: void 0 },
    sortCompare: { type: Function, default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: [String, Boolean], default: void 0 },
    noProviderSorting: { type: [String, Boolean], default: void 0 },
    noProviderFiltering: { type: [String, Boolean], default: void 0 },
    responsive: { type: [Boolean, String], default: false },
    small: { type: [String, Boolean], default: false },
    striped: { type: [String, Boolean], default: false },
    stacked: { type: [Boolean, String], default: false },
    labelStacked: { type: Boolean, default: false },
    variant: { default: void 0 },
    sortBy: { default: void 0 },
    sortDesc: { type: [String, Boolean], default: false },
    sortInternal: { type: [String, Boolean], default: true },
    selectable: { type: [String, Boolean], default: false },
    stickySelect: { type: [String, Boolean], default: false },
    selectHead: { type: [Boolean, String], default: true },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { type: [String, Boolean], default: false },
    busy: { type: [String, Boolean], default: false },
    showEmpty: { type: [String, Boolean], default: false },
    perPage: { default: void 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" }
  },
  emits: ["headClicked", "rowClicked", "rowDblClicked", "rowHovered", "rowUnhovered", "rowSelected", "rowUnselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = ke(a, "sortBy", l), n = ke(a, "busy", l, { passive: true }), s = ke(a, "sortDesc", l, { passive: true }), r = useSlots(), u = gc(), f = d(() => a.footClone), v = d(s), p = d(() => a.sortInternal), c = d(() => a.selectable), g = d(() => a.stickySelect), B = d(() => a.labelStacked), m = d(n), V = d(() => a.showEmpty), b = d(() => a.noProviderPaging), T = d(() => a.noProviderSorting), _ = d(() => a.noProviderFiltering);
    u.filterEvent.value = async (E) => {
      if (I.value) {
        await ne();
        return;
      }
      const W = await wa(E);
      l("filtered", W);
    };
    const h2 = ref(/* @__PURE__ */ new Set([])), k = computed(() => h2.value.size > 0), C = computed(() => ({
      [`align-${a.align}`]: a.align !== void 0,
      "b-table-selectable": c.value,
      [`b-table-select-${a.selectMode}`]: c.value,
      "b-table-selecting user-select-none": c.value && k.value,
      "b-table-busy": m.value,
      "b-table-sortable": z.value,
      "b-table-sort-desc": z.value && v.value === true,
      "b-table-sort-asc": z.value && v.value === false
    })), w = computed(() => ({
      bordered: a.bordered,
      borderless: a.borderless,
      borderVariant: a.borderVariant,
      captionTop: a.captionTop,
      dark: a.dark,
      hover: a.hover,
      responsive: a.responsive,
      striped: a.striped,
      stacked: a.stacked,
      small: a.small,
      tableClass: C.value,
      tableVariant: a.variant,
      stickyHeader: a.stickyHeader
    })), P = computed(() => u.normaliseFields(a.fields, a.items)), F = computed(
      () => P.value.length + (c.value ? 1 : 0)
    ), S = computed(() => a.filter !== void 0 && a.filter !== ""), I = computed(() => a.provider !== void 0), x = computed(
      () => c.value && (!!a.selectHead || r.selectHead !== void 0)
    ), z = computed(
      () => a.fields.filter((E) => typeof E == "string" ? false : E.sortable).length > 0
    ), te = computed(() => z.value && p.value === true), Q = computed(() => {
      const E = I.value ? u.internalItems.value : te.value ? u.mapItems(a.fields, a.items, a, {
        isSortable: z,
        isFilterableTable: S,
        sortDescBoolean: v
      }) : a.items;
      if (I.value && !b.value)
        return E;
      if (a.perPage !== void 0) {
        const W = (a.currentPage - 1) * a.perPage, ge = W + a.perPage > E.length ? E.length : W + a.perPage;
        return E.slice(W, ge);
      }
      return E;
    }), G = (E) => typeof E == "string" ? ul(E) : E.label !== void 0 ? E.label : typeof E.key == "string" ? ul(E.key) : E.key, X = (E, W, ge = false) => {
      const L = typeof E == "string" ? E : E.key;
      l("headClicked", L, E, W, ge), ye(E);
    }, U = (E, W, ge) => {
      l("rowClicked", E, W, ge), ee(E, W, ge.shiftKey, ge.ctrlKey, ge.metaKey);
    }, pe = (E, W, ge) => l("rowDblClicked", E, W, ge), be = (E, W, ge) => l("rowHovered", E, W, ge), he = (E, W, ge) => l("rowUnhovered", E, W, ge), ye = (E) => {
      if (!z.value)
        return;
      const W = typeof E == "string" ? E : E.key, ge = typeof E == "string" ? false : E.sortable;
      if (z.value === true && ge === true) {
        const L = !v.value;
        W !== a.sortBy && (o.value = W), s.value = L, l("sorted", W, L);
      }
    }, q = () => {
      c.value && l("selection", Array.from(h2.value));
    }, ee = (E, W, ge = false, L = false, me = false) => {
      if (c.value) {
        if (ge && a.selectMode === "range" && h2.value.size > 0) {
          const ve = Array.from(h2.value).pop(), qt = Q.value.findIndex((At) => At === ve), ga = Math.min(qt, W), ya = Math.max(qt, W);
          Q.value.slice(ga, ya + 1).forEach((At) => {
            h2.value.has(At) || (h2.value.add(At), l("rowSelected", At));
          });
        } else
          L || me ? h2.value.has(E) ? (h2.value.delete(E), l("rowUnselected", E)) : a.selectMode === "range" || a.selectMode === "multi" ? (h2.value.add(E), l("rowSelected", E)) : (h2.value.forEach((ve) => l("rowUnselected", ve)), h2.value.clear(), h2.value.add(E), l("rowSelected", E)) : (h2.value.forEach((ve) => l("rowUnselected", ve)), h2.value.clear(), h2.value.add(E), l("rowSelected", E));
        q();
      }
    }, ne = async () => {
      if (!I.value || !a.provider || m.value)
        return;
      n.value = true;
      const E = new Proxy(
        {
          currentPage: a.currentPage,
          filter: a.filter,
          sortBy: a.sortBy,
          sortDesc: a.sortDesc,
          perPage: a.perPage
        },
        {
          get: (ge, L) => L in ge ? ge[L] : void 0,
          set: () => (console.error("BTable provider context is a read-only object."), true)
        }
      ), W = a.provider(E, u.updateInternalItems);
      if (W !== void 0) {
        if (W instanceof Promise)
          try {
            const ge = await W;
            return Array.isArray(ge) ? await u.updateInternalItems(ge) : void 0;
          } finally {
            m.value && (n.value = false);
          }
        try {
          return await u.updateInternalItems(W);
        } finally {
          m.value && (n.value = false);
        }
      }
    }, ue = (E) => {
      E._showDetails = !E._showDetails;
    }, N = (E) => [
      E.class,
      E.thClass,
      {
        [`table-${E.variant}`]: E.variant !== null,
        "b-table-sortable-column": z.value && E.sortable,
        "b-table-sticky-column": E.stickyColumn
      }
    ], le = (E, W) => [
      E.class,
      E.tdClass,
      W != null && W._cellVariants && (W != null && W._cellVariants[E.key]) ? `table-${W == null ? void 0 : W._cellVariants[E.key]}` : void 0,
      {
        [`table-${E.variant}`]: E.variant !== null,
        "b-table-sticky-column": E.stickyColumn
      }
    ], de = (E) => [
      E._rowVariant ? `table-${E._rowVariant}` : null,
      E._rowVariant ? `table-${E._rowVariant}` : null,
      c.value && h2.value.has(E) ? `selected table-${a.selectionVariant}` : null
    ], Se = () => {
      if (!c.value)
        return;
      const E = h2.value.size > 0 ? Array.from(h2.value) : [];
      h2.value = /* @__PURE__ */ new Set([...Q.value]), h2.value.forEach((W) => {
        E.includes(W) || l("rowSelected", W);
      }), q();
    }, Ce = () => {
      c.value && (h2.value.forEach((E) => {
        l("rowUnselected", E);
      }), h2.value = /* @__PURE__ */ new Set([]), q());
    }, K = (E) => {
      if (!c.value)
        return;
      const W = Q.value[E];
      !W || h2.value.has(W) || (h2.value.add(W), l("rowSelected", W), q());
    }, ce = (E) => {
      if (!c.value)
        return;
      const W = Q.value[E];
      !W || !h2.value.has(W) || (h2.value.delete(W), l("rowUnselected", W), q());
    }, Le = async (E, W, ge) => {
      if (W === ge)
        return;
      const L = (ya) => a.noProvider && a.noProvider.includes(ya), me = !["currentPage", "perPage"].includes(E), ve = ["currentPage", "perPage"].includes(E) && (L("paging") || b.value === true), qt = ["filter"].includes(E) && (L("filtering") || _.value === true), ga = ["sortBy", "sortDesc"].includes(E) && (L("sorting") || T.value === true);
      ve || qt || ga || (await ne(), me && u.notifyFilteredItems());
    };
    return watch(
      () => a.filter,
      (E, W) => {
        E === W || I.value || E || wa(a.items).then((ge) => l("filtered", ge));
      }
    ), watch(
      () => a.filter,
      (E, W) => Le("filter", E, W)
    ), watch(
      () => a.currentPage,
      (E, W) => Le("currentPage", E, W)
    ), watch(
      () => a.perPage,
      (E, W) => Le("perPage", E, W)
    ), watch(
      () => a.sortBy,
      (E, W) => Le("sortBy", E, W)
    ), watch(
      () => a.sortDesc,
      (E, W) => Le("sortDesc", E, W)
    ), onMounted(() => {
      I.value && ne();
    }), t({
      selectAllRows: Se,
      clearSelected: Ce,
      selectRow: K,
      unselectRow: ce,
      refresh: ne
    }), (E, W) => (openBlock(), createBlock(rl, normalizeProps(guardReactiveProps(w.value)), {
      default: withCtx(() => {
        var ge;
        return [
          createBaseVNode("thead", null, [
            E.$slots["thead-top"] ? renderSlot(E.$slots, "thead-top", { key: 0 }) : createCommentVNode("", true),
            createBaseVNode("tr", null, [
              x.value ? (openBlock(), createElementBlock("th", {
                key: 0,
                class: normalizeClass(["b-table-selection-column", {
                  "b-table-sticky-column": unref(g)
                }])
              }, [
                renderSlot(E.$slots, "select-head", {}, () => [
                  createTextVNode(toDisplayString(typeof E.selectHead == "boolean" ? "Selected" : E.selectHead), 1)
                ])
              ], 2)) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(P.value, (L) => (openBlock(), createElementBlock("th", mergeProps({
                key: L.key,
                scope: "col",
                class: N(L),
                title: L.headerTitle,
                abbr: L.headerAbbr,
                style: L.thStyle
              }, L.thAttr, {
                onClick: (me) => X(L, me)
              }), [
                createBaseVNode("div", bc, [
                  renderSlot(E.$slots, "sort-icon", {
                    field: L,
                    sortBy: E.sortBy,
                    selected: L.key === E.sortBy,
                    isDesc: unref(v),
                    direction: unref(v) ? "desc" : "asc"
                  }, () => [
                    z.value && L.sortable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: normalizeClass(["b-table-sort-icon", {
                        sorted: L.key === E.sortBy,
                        [`sorted-${unref(v) ? "desc" : "asc"}`]: L.key === E.sortBy
                      }])
                    }, null, 2)) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", null, [
                    E.$slots["head(" + L.key + ")"] || E.$slots["head()"] ? renderSlot(E.$slots, E.$slots["head(" + L.key + ")"] ? "head(" + L.key + ")" : "head()", {
                      key: 0,
                      label: L.label,
                      column: L.key,
                      field: L,
                      isFoot: false,
                      selectAllRows: Se,
                      clearSelected: Ce
                    }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(G(L)), 1)
                    ], 64))
                  ])
                ])
              ], 16, yc))), 128))
            ]),
            E.$slots["thead-sub"] ? (openBlock(), createElementBlock("tr", hc, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(P.value, (L) => (openBlock(), createElementBlock("td", {
                key: L.key,
                scope: "col",
                class: normalizeClass([L.class, L.thClass, L.variant ? `table-${L.variant}` : ""])
              }, [
                E.$slots["thead-sub"] ? renderSlot(E.$slots, "thead-sub", mergeProps({
                  key: 0,
                  items: P.value
                }, L)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(L.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("tbody", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(Q.value, (L, me) => (openBlock(), createElementBlock(Fragment, { key: me }, [
              createBaseVNode("tr", {
                class: normalizeClass(de(L)),
                onClick: (ve) => !unref(Xt)(ve) && U(L, me, ve),
                onDblclick: (ve) => !unref(Xt)(ve) && pe(L, me, ve),
                onMouseenter: (ve) => !unref(Xt)(ve) && be(L, me, ve),
                onMouseleave: (ve) => !unref(Xt)(ve) && he(L, me, ve)
              }, [
                x.value ? (openBlock(), createElementBlock("td", {
                  key: 0,
                  class: normalizeClass(["b-table-selection-column", {
                    "b-table-sticky-column": unref(g)
                  }])
                }, [
                  renderSlot(E.$slots, "select-cell", {}, () => [
                    createBaseVNode("span", {
                      class: normalizeClass(h2.value.has(L) ? "text-primary" : "")
                    }, "ð¹", 2)
                  ])
                ], 2)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(P.value, (ve) => (openBlock(), createElementBlock("td", mergeProps({
                  key: ve.key
                }, ve.tdAttr, {
                  class: le(ve, L)
                }), [
                  E.stacked && unref(B) ? (openBlock(), createElementBlock("label", Sc, toDisplayString(G(ve)), 1)) : createCommentVNode("", true),
                  E.$slots["cell(" + ve.key + ")"] || E.$slots["cell()"] ? renderSlot(E.$slots, E.$slots["cell(" + ve.key + ")"] ? "cell(" + ve.key + ")" : "cell()", {
                    key: 1,
                    value: L[ve.key],
                    index: me,
                    item: L,
                    field: ve,
                    items: E.items,
                    toggleDetails: () => ue(L),
                    detailsShowing: L._showDetails
                  }) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createTextVNode(toDisplayString(unref(u).formatItem(L, ve)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, Bc),
              L._showDetails === true && E.$slots["row-details"] ? (openBlock(), createElementBlock("tr", {
                key: 0,
                class: normalizeClass(de(L))
              }, [
                createBaseVNode("td", { colspan: F.value }, [
                  renderSlot(E.$slots, "row-details", {
                    item: L,
                    toggleDetails: () => ue(L)
                  })
                ], 8, _c)
              ], 2)) : createCommentVNode("", true)
            ], 64))), 128)),
            unref(m) ? (openBlock(), createElementBlock("tr", {
              key: 0,
              class: normalizeClass(["b-table-busy-slot", { "b-table-static-busy": Q.value.length === 0 }])
            }, [
              createBaseVNode("td", { colspan: F.value }, [
                renderSlot(E.$slots, "table-busy", {}, () => [
                  createBaseVNode("div", $c, [
                    createVNode(ma, { class: "align-middle" }),
                    kc
                  ])
                ])
              ], 8, wc)
            ], 2)) : createCommentVNode("", true),
            unref(V) && Q.value.length === 0 ? (openBlock(), createElementBlock("tr", Cc, [
              createBaseVNode("td", { colspan: F.value }, [
                renderSlot(E.$slots, "empty", {
                  items: Q.value,
                  filtered: S.value
                }, () => [
                  createTextVNode(toDisplayString(S.value ? E.emptyFilteredText : E.emptyText), 1)
                ])
              ], 8, Tc)
            ])) : createCommentVNode("", true)
          ]),
          unref(f) ? (openBlock(), createElementBlock("tfoot", Vc, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(P.value, (L) => (openBlock(), createElementBlock("th", mergeProps({
                key: L.key
              }, L.thAttr, {
                scope: "col",
                class: [L.class, L.thClass, L.variant ? `table-${L.variant}` : ""],
                title: L.headerTitle,
                abbr: L.headerAbbr,
                style: L.thStyle,
                onClick: (me) => X(L, me, true)
              }), toDisplayString(L.label), 17, Oc))), 128))
            ])
          ])) : E.$slots["custom-foot"] ? (openBlock(), createElementBlock("tfoot", Ac, [
            renderSlot(E.$slots, "custom-foot", {
              fields: P.value,
              items: E.items,
              columns: (ge = P.value) == null ? void 0 : ge.length
            })
          ])) : createCommentVNode("", true),
          E.$slots["table-caption"] ? (openBlock(), createElementBlock("caption", Pc, [
            renderSlot(E.$slots, "table-caption")
          ])) : E.caption ? (openBlock(), createElementBlock("caption", Ec, toDisplayString(E.caption), 1)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 16));
  }
});
var Ic = defineComponent({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`thead-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (openBlock(), createElementBlock("tbody", {
      class: normalizeClass(l.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var xc = ["scope", "colspan", "rowspan", "data-label"];
var Lc = { key: 0 };
var Nc = defineComponent({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: false },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = d(() => t.stickyColumn), a = computed(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": l.value,
      "table-b-table-default": l.value && t.variant === null
    })), o = computed(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, s) => (openBlock(), createElementBlock("td", {
      scope: o.value,
      class: normalizeClass(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading ? (openBlock(), createElementBlock("div", Lc, [
        renderSlot(n.$slots, "default")
      ])) : renderSlot(n.$slots, "default", { key: 1 })
    ], 10, xc));
  }
});
var zc = defineComponent({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (openBlock(), createElementBlock("tfoot", {
      class: normalizeClass(l.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var Hc = ["scope", "colspan", "rowspan", "data-label"];
var Rc = { key: 0 };
var Mc = defineComponent({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: false },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = d(() => t.stickyColumn), a = computed(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": l.value,
      "table-b-table-default": l.value && t.variant === null
    })), o = computed(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, s) => (openBlock(), createElementBlock("th", {
      scope: o.value,
      class: normalizeClass(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading !== void 0 ? (openBlock(), createElementBlock("div", Rc, [
        renderSlot(n.$slots, "default")
      ])) : renderSlot(n.$slots, "default", { key: 1 })
    ], 10, Hc));
  }
});
var Dc = defineComponent({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (openBlock(), createElementBlock("thead", {
      class: normalizeClass(l.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var jc = defineComponent({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = computed(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (openBlock(), createElementBlock("tr", {
      class: normalizeClass(l.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var qc = defineComponent({
  __name: "BTab",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    active: { type: [String, Boolean], default: false },
    buttonId: { default: void 0 },
    disabled: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: void 0 },
    lazyOnce: { type: [String, Boolean], default: void 0 },
    noBody: { type: [Boolean, String], default: false },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, l = inject(wo, null), a = d(() => t.active), o = d(() => t.disabled), n = d(
      computed(() => t.lazyOnce !== void 0 ? t.lazyOnce : t.lazy)
    ), s = ref(false), r = computed(() => !!(l != null && l.lazy.value || n.value)), u = computed(() => t.lazyOnce !== void 0), f = computed(() => a.value && !o.value), v = computed(() => {
      const g = r.value && u.value && s.value;
      return f.value || !r.value || g;
    }), p = ref(a.value);
    watch(a, (g) => {
      setTimeout(() => {
        p.value = g;
      }, 0);
    });
    const c = computed(() => ({
      active: a.value,
      show: p.value,
      "card-body": (l == null ? void 0 : l.card.value) && t.noBody === false
    }));
    return watch(v, (g) => {
      g && !s.value && (s.value = true);
    }), (g, B) => (openBlock(), createBlock(resolveDynamicComponent(g.tag), {
      id: g.id,
      class: normalizeClass(["tab-pane", c.value]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: withCtx(() => [
        v.value ? renderSlot(g.$slots, "default", { key: 0 }) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var Gc = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"];
var Wc = defineComponent({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    contentClass: { default: void 0 },
    card: { type: [String, Boolean], default: false },
    end: { type: [String, Boolean], default: false },
    fill: { type: [String, Boolean], default: false },
    id: { default: void 0 },
    justified: { type: [String, Boolean], default: false },
    lazy: { type: [String, Boolean], default: false },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: [String, Boolean], default: false },
    noNavStyle: { type: [String, Boolean], default: false },
    pills: { type: [String, Boolean], default: false },
    small: { type: [String, Boolean], default: false },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: false },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const l = e, a = ke(l, "modelValue", t), o = useSlots(), n = d(() => l.card), s = d(() => l.end), r = d(() => l.fill), u = d(() => l.justified), f = d(() => l.lazy), v = d(() => l.noFade), p = d(() => l.noNavStyle), c = d(() => l.pills), g = d(() => l.small), B = d(() => l.vertical), m = ref(a.value), V = ref(""), b = computed({
      get: () => m.value,
      set: (S) => {
        m.value = S, _.value.length > 0 && S >= 0 && S < _.value.length ? V.value = _.value[S].buttonId : V.value = "", a.value = S;
      }
    }), T = ref([]);
    watch(
      () => {
        var S;
        return (S = o.default) == null ? void 0 : S.call(o);
      },
      () => {
        T.value = o.default === void 0 ? [] : $a(o.default, "BTab").map((S, I) => {
          S.props || (S.props = {});
          const x = S.props["button-id"] || lt("tab"), z = S.props.id || lt(), te = S.props["title-item-class"], Q = S.props["title-link-attributes"];
          return {
            buttonId: x,
            contentId: z,
            disabled: S.props.disabled === "" || S.props.disabled === true,
            target: `#${z}`,
            title: S.props.title,
            titleItemClass: te,
            titleLinkAttributes: Q,
            onClick: S.props.onClick,
            tab: S,
            tabComponent: () => $a(o.default, "BTab")[I]
          };
        });
      },
      { immediate: true }
    );
    const _ = computed(
      () => T.value.map((S, I) => {
        const { tab: x } = S;
        x.props || (x.props = {});
        const z = b.value > -1 ? I === b.value : x.props.active === "";
        return {
          ...S,
          active: z,
          navItemClasses: [
            {
              active: z,
              disabled: x.props.disabled === "" || x.props.disabled === true
            },
            z && l.activeNavItemClass ? l.activeNavItemClass : null,
            x.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !v.value
            },
            z && l.activeTabClass ? l.activeTabClass : null
          ]
        };
      })
    ), h2 = computed(() => !(_ != null && _.value && _.value.length > 0)), k = computed(() => ({
      "d-flex": B.value,
      "align-items-start": B.value
    })), C = jt(() => l.align), w = computed(() => ({
      "nav-pills": c.value,
      "flex-column me-3": B.value,
      [C.value]: l.align !== void 0,
      "nav-fill": r.value,
      "card-header-tabs": n.value,
      "nav-justified": u.value,
      "nav-tabs": !p.value && !c.value,
      small: g.value
    })), P = (S) => {
      let I = false;
      if (S !== void 0 && S > -1 && S < _.value.length && !_.value[S].disabled && (b.value < 0 || _.value[S].buttonId !== V.value)) {
        const x = new Je("activate-tab", { cancelable: true });
        t("activate-tab", S, b.value, x), x.defaultPrevented || (b.value = S, I = true);
      }
      return !I && a.value !== b.value && (a.value = b.value), I;
    }, F = (S, I) => {
      var x;
      P(I), I >= 0 && !_.value[I].disabled && ((x = _.value[I]) != null && x.onClick) && typeof _.value[I].onClick == "function" && _.value[I].onClick(S);
    };
    return P(m.value), watch(a, (S, I) => {
      if (S === I)
        return;
      if (S = Math.max(S, -1), I = Math.max(I, -1), _.value.length <= 0) {
        b.value = -1;
        return;
      }
      const x = S > I;
      let z = S;
      const te = _.value.length - 1;
      for (; z >= 0 && z <= te && _.value[z].disabled; )
        z += x ? 1 : -1;
      if (z < 0) {
        P(0);
        return;
      }
      if (z >= _.value.length) {
        P(_.value.length - 1);
        return;
      }
      P(z);
    }), watch(_, () => {
      let S = _.value.map((I) => I.active && !I.disabled).lastIndexOf(true);
      S < 0 && (b.value >= _.value.length ? S = _.value.map((I) => !I.disabled).lastIndexOf(true) : _.value[b.value] && !_.value[b.value].disabled && (S = b.value)), S < 0 && (S = _.value.map((I) => !I.disabled).indexOf(true)), _.value.forEach((I, x) => {
        I.active = x === S;
      }), P(S);
    }), onMounted(() => {
      if (b.value < 0 && _.value.length > 0 && !_.value.some((S) => S.active)) {
        const S = _.value.map((I) => !I.disabled).indexOf(true);
        P(S >= 0 ? S : -1);
      }
    }), provide(wo, {
      lazy: f,
      card: n
    }), (S, I) => (openBlock(), createBlock(resolveDynamicComponent(S.tag), {
      id: S.id,
      class: normalizeClass(["tabs", k.value])
    }, {
      default: withCtx(() => [
        unref(s) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["tab-content", S.contentClass])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_.value, ({ tabComponent: x, contentId: z, tabClasses: te, active: Q }, G) => (openBlock(), createBlock(resolveDynamicComponent(x()), {
            id: z,
            key: G,
            class: normalizeClass(te),
            active: Q
          }, null, 8, ["id", "class", "active"]))), 128)),
          h2.value ? (openBlock(), createElementBlock("div", {
            key: "bv-empty-tab",
            class: normalizeClass(["tab-pane active", { "card-body": unref(n) }])
          }, [
            renderSlot(S.$slots, "empty")
          ], 2)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass([S.navWrapperClass, { "card-header": unref(n), "ms-auto": S.vertical && unref(s) }])
        }, [
          createBaseVNode("ul", {
            class: normalizeClass(["nav", [w.value, S.navClass]]),
            role: "tablist"
          }, [
            renderSlot(S.$slots, "tabs-start"),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_.value, ({ tab: x, buttonId: z, contentId: te, navItemClasses: Q, active: G, target: X }, U) => {
              var pe, be, he;
              return openBlock(), createElementBlock("li", {
                key: U,
                class: normalizeClass(["nav-item", (pe = x == null ? void 0 : x.props) == null ? void 0 : pe["title-item-class"]]),
                role: "presentation"
              }, [
                createBaseVNode("button", mergeProps({
                  id: z,
                  class: ["nav-link", Q],
                  "data-bs-toggle": "tab",
                  "data-bs-target": X,
                  role: "tab",
                  "aria-controls": te,
                  "aria-selected": G
                }, (be = x == null ? void 0 : x.props) == null ? void 0 : be["title-link-attributes"], {
                  onClick: withModifiers((ye) => F(ye, U), ["stop", "prevent"])
                }), [
                  x.children && x.children.title ? (openBlock(), createBlock(resolveDynamicComponent(x.children.title), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString((he = x == null ? void 0 : x.props) == null ? void 0 : he.title), 1)
                  ], 64))
                ], 16, Gc)
              ], 2);
            }), 128)),
            renderSlot(S.$slots, "tabs-end")
          ], 2)
        ], 2),
        unref(s) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["tab-content", S.contentClass])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_.value, ({ tabComponent: x, contentId: z, tabClasses: te, active: Q }, G) => (openBlock(), createBlock(resolveDynamicComponent(x()), {
            id: z,
            key: G,
            class: normalizeClass(te),
            active: Q
          }, null, 8, ["id", "class", "active"]))), 128)),
          h2.value ? (openBlock(), createElementBlock("div", {
            key: "bv-empty-tab",
            class: normalizeClass(["tab-pane active", { "card-body": unref(n) }])
          }, [
            renderSlot(S.$slots, "empty")
          ], 2)) : createCommentVNode("", true)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var Uc = defineComponent({
  __name: "BTooltip",
  setup(e, { expose: t }) {
    var a, o, n;
    const l = ref(null);
    return t({
      hide: (a = l.value) == null ? void 0 : a.hideFn,
      show: (o = l.value) == null ? void 0 : o.show,
      toggle: (n = l.value) == null ? void 0 : n.toggle
    }), (s, r) => (openBlock(), createBlock(tl, {
      ref_key: "popover",
      ref: l,
      tooltip: ""
    }, createSlots({ _: 2 }, [
      renderList(s.$slots, (u, f) => ({
        name: f,
        fn: withCtx((v) => [
          renderSlot(s.$slots, f, normalizeProps(guardReactiveProps(v)))
        ])
      }))
    ]), 1536));
  }
});
var no = Object.freeze(Object.defineProperty({
  __proto__: null,
  BAccordion: ni,
  BAccordionItem: ui,
  BAlert: pi,
  BAvatar: bi,
  BAvatarGroup: hi,
  BBadge: Bi,
  BBreadcrumb: wi,
  BBreadcrumbItem: cn,
  BButton: kt,
  BButtonGroup: $i,
  BButtonToolbar: Ci,
  BCard: bn,
  BCardBody: gn,
  BCardFooter: yn,
  BCardGroup: Oi,
  BCardHeader: vn,
  BCardImg: ia,
  BCardSubtitle: mn,
  BCardText: Ai,
  BCardTitle: pn,
  BCarousel: zi,
  BCarouselSlide: ji,
  BCloseButton: Ot,
  BCol: Pt,
  BCollapse: dn,
  BContainer: Yi,
  BDropdown: wn,
  BDropdownDivider: eu,
  BDropdownForm: lu,
  BDropdownGroup: su,
  BDropdownHeader: iu,
  BDropdownItem: uu,
  BDropdownItemButton: cu,
  BDropdownText: pu,
  BForm: $n,
  BFormCheckbox: kn,
  BFormCheckboxGroup: $u,
  BFormFile: Tu,
  BFormFloatingLabel: bu,
  BFormGroup: xu,
  BFormInput: Nu,
  BFormInvalidFeedback: Ea,
  BFormRadio: Tn,
  BFormRadioGroup: ju,
  BFormRow: Zt,
  BFormSelect: Uu,
  BFormSelectOption: ol,
  BFormSelectOptionGroup: Vn,
  BFormSpinButton: Zu,
  BFormTag: Fn,
  BFormTags: vd,
  BFormText: Fa,
  BFormTextarea: md,
  BFormValidFeedback: Ia,
  BImg: al,
  BInputGroup: _d,
  BInputGroupAddon: nl,
  BInputGroupAppend: wd,
  BInputGroupPrepend: $d,
  BInputGroupText: In,
  BLink: Qe,
  BListGroup: kd,
  BListGroupItem: Cd,
  BModal: Ad,
  BNav: Pd,
  BNavForm: Ed,
  BNavItem: Id,
  BNavItemDropdown: Ld,
  BNavText: zd,
  BNavbar: Hd,
  BNavbarBrand: Rd,
  BNavbarNav: Md,
  BNavbarToggle: Ud,
  BOffcanvas: Yd,
  BOverlay: Ln,
  BPagination: nc,
  BPlaceholder: Re,
  BPlaceholderButton: Hn,
  BPlaceholderCard: sc,
  BPlaceholderTable: rc,
  BPlaceholderWrapper: ic,
  BPopover: tl,
  BProgress: dc,
  BProgressBar: Rn,
  BRow: vc,
  BSpinner: ma,
  BTab: qc,
  BTable: Fc,
  BTableSimple: rl,
  BTabs: Wc,
  BTbody: Ic,
  BTd: Nc,
  BTfoot: zc,
  BTh: Mc,
  BThead: Dc,
  BToast: _n,
  BToastContainer: Pa,
  BToastPlugin: Sn,
  BToaster: Pa,
  BTooltip: Uc,
  BTr: jc,
  BTransition: Vt
}, Symbol.toStringTag, { value: "Module" }));
var Yc = Object.freeze(Object.defineProperty({
  __proto__: null,
  useBreadcrumb: Qo,
  useColorMode: Xr
}, Symbol.toStringTag, { value: "Module" }));
var Jc = Object.freeze(Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: vo,
  BvEvent: Je,
  BvTriggerableEvent: Mt
}, Symbol.toStringTag, { value: "Module" }));
var Zc = Object.freeze(Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Qc = {
  install(e, t = { components: true, directives: true }) {
    const l = typeof t.components == "boolean" || typeof t.components > "u" ? { all: true } : t.components, a = Object.keys(no);
    zl(l, a).forEach((s) => {
      const r = no[s];
      e.component(s, r);
    });
    const o = typeof (t == null ? void 0 : t.directives) == "boolean" || typeof t.directives > "u" ? { all: true } : t == null ? void 0 : t.directives, n = Object.keys(to);
    zl(o, n).forEach((s) => {
      const r = s.toLowerCase().startsWith("v") ? s.slice(1) : s, u = to[s];
      e.directive(r, u);
    }), t != null && t.BToast && e.use(Sn, t);
  }
};
export {
  ni as BAccordion,
  ui as BAccordionItem,
  pi as BAlert,
  bi as BAvatar,
  hi as BAvatarGroup,
  Bi as BBadge,
  wi as BBreadcrumb,
  cn as BBreadcrumbItem,
  kt as BButton,
  $i as BButtonGroup,
  Ci as BButtonToolbar,
  bn as BCard,
  gn as BCardBody,
  yn as BCardFooter,
  Oi as BCardGroup,
  vn as BCardHeader,
  ia as BCardImg,
  mn as BCardSubtitle,
  Ai as BCardText,
  pn as BCardTitle,
  zi as BCarousel,
  ji as BCarouselSlide,
  Ot as BCloseButton,
  Pt as BCol,
  dn as BCollapse,
  Yi as BContainer,
  wn as BDropdown,
  eu as BDropdownDivider,
  lu as BDropdownForm,
  su as BDropdownGroup,
  iu as BDropdownHeader,
  uu as BDropdownItem,
  cu as BDropdownItemButton,
  pu as BDropdownText,
  $n as BForm,
  kn as BFormCheckbox,
  $u as BFormCheckboxGroup,
  Tu as BFormFile,
  bu as BFormFloatingLabel,
  xu as BFormGroup,
  Nu as BFormInput,
  Ea as BFormInvalidFeedback,
  Tn as BFormRadio,
  ju as BFormRadioGroup,
  Zt as BFormRow,
  Uu as BFormSelect,
  ol as BFormSelectOption,
  Vn as BFormSelectOptionGroup,
  Zu as BFormSpinButton,
  Fn as BFormTag,
  vd as BFormTags,
  Fa as BFormText,
  md as BFormTextarea,
  Ia as BFormValidFeedback,
  al as BImg,
  _d as BInputGroup,
  nl as BInputGroupAddon,
  wd as BInputGroupAppend,
  $d as BInputGroupPrepend,
  In as BInputGroupText,
  Qe as BLink,
  kd as BListGroup,
  Cd as BListGroupItem,
  Ad as BModal,
  Pd as BNav,
  Ed as BNavForm,
  Id as BNavItem,
  Ld as BNavItemDropdown,
  zd as BNavText,
  Hd as BNavbar,
  Rd as BNavbarBrand,
  Md as BNavbarNav,
  Ud as BNavbarToggle,
  Yd as BOffcanvas,
  Ln as BOverlay,
  nc as BPagination,
  Re as BPlaceholder,
  Hn as BPlaceholderButton,
  sc as BPlaceholderCard,
  rc as BPlaceholderTable,
  ic as BPlaceholderWrapper,
  tl as BPopover,
  dc as BProgress,
  Rn as BProgressBar,
  vc as BRow,
  ma as BSpinner,
  qc as BTab,
  Fc as BTable,
  rl as BTableSimple,
  Wc as BTabs,
  Ic as BTbody,
  Nc as BTd,
  zc as BTfoot,
  Mc as BTh,
  Dc as BThead,
  _n as BToast,
  Pa as BToastContainer,
  Sn as BToastPlugin,
  Pa as BToaster,
  Uc as BTooltip,
  jc as BTr,
  Vt as BTransition,
  Qc as BootstrapVueNext,
  vo as BvCarouselEvent,
  Je as BvEvent,
  Mt as BvTriggerableEvent,
  no as Components,
  Yc as Composables,
  to as Directives,
  Zc as Types,
  Jc as Utils,
  Qc as default,
  Qo as useBreadcrumb,
  Xr as useColorMode,
  Bn as useToast,
  Dd as vBColorMode,
  Na as vBModal,
  qd as vBPopover,
  Na as vBToggle,
  Gd as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.js.map
